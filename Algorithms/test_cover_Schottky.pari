/*
This file contains functions for testing the algorithms in
cover_Schottky.pari. NOTE: need to run "\r flare_disk_Schottky.pari"
in gp before running any code in this file, since it assumes those
functions are defined.
*/

/**********************************************************************
  Functions for generating test points
**********************************************************************/

/*
Generates N admissible test points randomly in the unit disk.
*/
test_points_random(N, thet, alpha0)=
{
  local(zs, circles, z1, z2, t, pre_kappa, pts_found, pts_considered,
        rand_norm, rand_arg, z_disk, z, z_flare, zpb, zpb_flare, prec, re);

  prec = default(realprecision);
  re = 10^(-prec);

  zs = vector(N);

  /* get circle and flare data */
  circles = get_circles_UHP(Pi/2);
  [z1, z2, t, pre_kappa] = get_flare_data(circles);

  /* keep generating random test points until we find N */
  pts_found = 0;
  pts_considered = 0;
  while(pts_found < N,
    /* get random point in disk */
    rand_norm = random()/2^31;
    rand_arg = 2*Pi*random()/2^31;
    z_disk = rand_norm*exp(I*rand_arg);

    /* get corresponding point (and pullback) in UHP and flare */
    z = inv_cayley_transform(z_disk);
    z_flare = true_to_hyp(z, z1, z2, t);
    zpb = pullback_Schottky(z, circles);
    zpb_flare = true_to_hyp(zpb, z1, z2, t);

    /* if not in fundamental domain, continue */
    if(abs(z - zpb) >= 10e-10,
      /* if point and pullback have different args in flare, continue */
      if(abs(z_flare[2] - zpb_flare[2]) >= 10e-10,
        /* if both points admissible wrt flare, continue */
        if(z_flare[2] <= alpha0,
          if(zpb_flare[2] <= alpha0,
            /* if we got here, we have a test point! */
            pts_found += 1;
            zs[pts_found] = z;
          );
        );
      );
    );

    pts_considered += 1;
    if(pts_considered >= 1000*N,
      print("Considered "pts_considered" points and found "pts_found" to be used.");
      error("Could not find enough test points.");
    );
  );

  print("Considered "pts_considered" points.");
  return(zs);
}

/**********************************************************************
  Experiments
**********************************************************************/

/* Run one iteration of the secant method zoom in */
/* TODO: rewrite function! */
example_secant() =
{
  local(alpha0, rho0 s, M1, M2, delta, N1, N2, z1, z2, alpha1, alpha2,
        beta1, beta2, zs_FD, zs_non_FD, circles_doubled, refl_cent, refl_rad,
        circles_shifted, flare_data, s_guess);

  /*default(realprecision, 60);*/

  /* Parameters */
  thet = Pi/6;

  alpha0 = Pi; M1 = 20;
  rho0 = 1; M2 = 20;

  alpha1 = Pi/4; alpha2 = Pi/6; N1 = 35;
  beta1 = 9*Pi/10; beta2 = 4*Pi/5; N2 = 35;

  s = 0.743; delta = 3e-3;

  /* Schottky group data */
  [circles_doubled, refl_cent, refl_rad, circles_shifted] = get_circle_data(thet);
  flare_data = get_flare_data(circles_doubled, refl_cent, refl_rad, circles_shifted);

  /* Get test points */
  zs_FD = test_points_FD(N1, flare_data, alpha1);
  zs_non_FD = test_points_non_FD(N2, flare_data, beta1);
  z1 = concat(zs_FD, zs_non_FD);
  zs_FD = test_points_FD(N1, flare_data, alpha2);
  zs_non_FD = test_points_non_FD(N2, flare_data, beta2);
  z2 = concat(zs_FD, zs_non_FD);

  s_guess = secant_method(z1, z2, alpha0, rho0, M1, M2, flare_data, circles_doubled, refl_cent, refl_rad, s, delta);
  print("Final guess: s = "s_guess);
}

/**********************************************************************
  Miscellaneous test functions
**********************************************************************/

test_circles_UHP()=
{
  circles = get_circles_UHP(Pi/2);
  print(circles);
  print();

  [z1, z2, t, pre_kappa] = get_flare_data(circles);
  print("z1");
  print(z1);
  print();
  print("z2");
  print(z2);
  print();
  print("t");
  print(t);
  print();
  print("pre_kappa");
  print(pre_kappa);
}

test_pullback()=
{
  local(circles, zs, ws);

  circles = get_circles_UHP(Pi/2);

  zs = vector(100, x, (x - 1)/20 + 5 + I/10);
  print(zs);
  print();
  ws = vector(100);

  for(i = 1, 100,
    ws[i] = pullback_Schottky(zs[i], circles);
  );
  print(ws);
}

test_flare_map()=
{
  local(circles, z1, z2, t, pre_kappa, z, w);

  circles = get_circles_UHP(Pi/2);

  [z1, z2, t, pre_kappa] = get_flare_data(circles);
  print("kappa = "true_to_hyp(pre_kappa, z1, z2, t));
  print(" ");

  /* test point in flare */
  z = -1.5 + 1/10*I;
  w = true_to_hyp(z, z1, z2, t);
  print("z = "z);
  print("U(z) = "w);
  print("U^{-1}(U(z)) = "hyp_to_true(w[1], w[2], z1, z2, t));
  print(" ");

  /* test point just outside flare */
  z = -2.5 + 1/10*I;
  w = true_to_hyp(z, z1, z2, t);
  print("z = "z);
  print("U(z) = "w);
  print("U^{-1}(U(z)) = "hyp_to_true(w[1], w[2], z1, z2, t));
  print(" ");

  /* test point near 0 */
  z = -8 + 1/10*I;
  w = true_to_hyp(z, z1, z2, t);
  print("z = "z);
  print("U(z) = "w);
  print("U^{-1}(U(z)) = "hyp_to_true(w[1], w[2], z1, z2, t));
  print(" ");

  /* test point near infinity */
  z = -0.7 + 1/10*I;
  w = true_to_hyp(z, z1, z2, t);
  print("z = "z);
  print("U(z) = "w);
  print("U^{-1}(U(z)) = "hyp_to_true(w[1], w[2], z1, z2, t));
  print(" ");
}

test_init_eqns()=
{
  local(A, circles, z1, z2, t, pre_kappa, zs, s, alpha0, rho0, M1, M2);

  /* Schottky group data */
  circles = get_circles_UHP(Pi/6);
  [z1, z2, t, pre_kappa] = get_flare_data(circles);

  /* Some test z values */
  zs = vector(3);
  zs[1] = 10 + 1/10*I;
  zs[2] = -9.4 + I;
  zs[3] = 1/20*I;

  /* Parameters */
  s = 0.4;
  alpha0 = Pi;
  M = 3;

  A = init_eqns(zs, s, alpha0, M, circles, z1, z2, t, pre_kappa);
  default(realprecision, 5);
  print(A);
  default(realprecision, 38);
}

test_test_points()=
{
  local(N, thet, alpha0, zs);

  N = 100;
  thet = Pi/6;
  alpha0 = 3*Pi/4;

  zs = test_points_random(N, thet, alpha0);

  print(zs);
}

/* TODO: update below! */

test_true_s()=
{
  local(alpha0, rho0, s, M1, M2, delta, N1, N2, z1, z2, alpha1, alpha2,
        beta1, beta2, zs_FD, zs_non_FD, circles_doubled, refl_cent, refl_rad,
        circles_shifted, flare_data);

  default(realprecision, 60);

  /* Parameters */
  thet = Pi/6;

  alpha0 = 4*Pi/5; M1 = 30;
  rho0 = 1; M2 = 30;

  alpha1 = Pi/4; alpha2 = Pi/6; N1 = 80;
  beta1 = 9*Pi/10; beta2 = 4*Pi/5; N2 = 0;

  s = 0.74306238;

  /* Schottky group data */
  [circles_doubled, refl_cent, refl_rad, circles_shifted] = get_circle_data(thet);
  flare_data = get_flare_data(circles_doubled, refl_cent, refl_rad, circles_shifted);

  /* Get test points */
  /*zs_FD = test_points_FD(N1, flare_data, alpha1);
  zs_non_FD = test_points_non_FD(N2, flare_data, beta1);
  z1 = concat(zs_FD, zs_non_FD);
  zs_FD = test_points_FD(N1, flare_data, alpha2);
  zs_non_FD = test_points_non_FD(N2, flare_data, beta2);
  z2 = concat(zs_FD, zs_non_FD);*/

  z1 = test_points_rect(5*(N1 + N2));
  z2 = test_points_rect(5*(N1 + N2));

  x1 = get_coefficients(z1, s, alpha0, rho0, M1, M2, flare_data, circles_doubled, refl_cent, refl_rad);
  x2 = get_coefficients(z2, s, alpha0, rho0, M1, M2, flare_data, circles_doubled, refl_cent, refl_rad);

  print("x1 = "precision(x1, 1));
  print(" ");
  print("x2 = "precision(x2, 1));
  print(" ");
  print("x1 - x2 = "precision(x1-x2, 1));
}
