/*
This file contains functions for testing the algorithms in
H3_flares.pari. NOTE: need to run "\r H3-flares.pari"
in gp before running any code in this file, since it assumes those
functions are defined.
*/

/**********************************************************************
  Functions for generating test points
**********************************************************************/

/*
To be admissible, a point cannot be in the fundamental domain, and its pullback
must have different azimuthal AND polar angles.
TODO: think about what admissible means in this case. Maybe it isn't a concern
      in 3-space.
*/
is_admissible()=
{
  TODO;
}

/*
Generates N test points in the flare domain at angle [thet, phi] evenly spaced
(in log space) from 1 to sqrt(kappa). Returns those points in original domain.
*/
test_points_ray(N, thet, phi)=
{
  /* here is the kappa we use for the Apollonian packing */
  kappa = (3 + sqrt(5))/(3 - sqrt(5));
  log_kappa = log(kappa);

  /* now form the points! */
  zs = vector(N);
  for(j = 1, N,
    zs[j] = hyp_to_true(exp(j/(2*N)*log_kappa), thet, phi);
  );

  return(zs);
}

/**********************************************************************
  Experiments
**********************************************************************/

/* Run one iteration of the secant method zoom in */
example_secant() =
{
  TODO;
}

/**********************************************************************
  Miscellaneous test functions
**********************************************************************/

test_quaternions()=
{
  local(q1, qi, qj, qk, q);

  /* make some quaternions */
  q1 = [1, 0, 0, 0];
  qi = [0, 1, 0, 0];
  qj = [0, 0, 1, 0];
  qk = [0, 0, 0, 1];

  /* try combination of these */
  q = Qadd(Qc(2, q1), Qc(3, qj));
  print(q);

  /* products */
  print(Qmult(q, q1));
  print(Qmult(q, qi));
  print(Qmult(q, qj));
  print(Qmult(q, qk));
  print(Qmult(q1, q));
  print(Qmult(qi, q));
  print(Qmult(qj, q));
  print(Qmult(qk, q));

  /* division should give inverse */
  print(Qdiv(q1, q1));
  print(Qdiv(qi, qi));
  print(Qdiv(qj, qj));
  print(Qdiv(qk, qk));
  print(Qdiv(q, q));
}

test_mobius()=
{
  local(T, S, A, qj);

  /* act on the k-free quaternion j */
  qj = [0, 0, 1];

  /* T shifts by 1 in x1-dimension */
  T = [[1, 1], [0, 1]];
  print(mobius(T, qj));

  /* S reflects through unit sphere and across x2-axis */
  S = [[0, -1], [1, 0]];
  print(mobius(S, qj));
  print(mobius(S, mobius(T, qj)));

  /* A negates real and i components and adds i */
  A = [[I, 1], [0, -I]];
  print(mobius(A, qj));
  print(mobius(A, [1, 1, -1]));
}

test_pullback()=
{
  local(zs);

  /* random UHP points */
  zs = [[0, 0, 1],
        [7, 2, 1],
        [-1.2, 1.5, 1],
        [0, -2, 0.5],
        [5.2, -2, 0.5],
        [1, 1, 1]];

  for(i = 1, length(zs),
    print(zs[i]", "pullback_Ap(zs[i]));
  );

  /* some points on the boundary */
  zs = [[0, 2, 0],
        [7, 0.5, 0],
        [-1.2, 1.5, 0],
        [-2.7, 0.2, 0]];

  print(" ");

  for(i = 1, length(zs),
    print(zs[i]", "pullback_Ap(zs[i]));
  );
}

test_Whitt()=
{
  print(flare_Whitt(1, 1, 1, 1.5, exp(1)));
  print(flare_Whitt(Pi/4, 2, 7, 1.72, exp(exp(1))));
  a = getwalltime();
  print(flare_Whitt(0.001, 21, 11, 1.1, exp(15)));
  b = getwalltime();
  print((b - a)/1000.0);
  print(flare_Whitt(Pi/2 - 0.01, 2, 5, 1.001, exp(6.8)));
  print(flare_Whitt(1.12, 2, 4, 1.98, exp(1.342)));
}

test_init_eqns()=
{
  local(A, circles, z1, z2, t, pre_kappa, zs, s, alpha0, rho0, M1, M2);

  /* Some test z values */
  zs = vector(3);
  zs[1] = [0, 0, 1/10];
  zs[2] = [1/2, 0, 1];
  zs[3] = [0, -2, 1];

  /* Parameters */
  s = 0.4;
  M = 3;

  A = init_eqns(zs, s, M);
  default(realprecision, 2);
  print(A);
  default(realprecision, 38);
}
