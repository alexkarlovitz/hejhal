/* This file contains PARI code to run Hejhal's algorithm on a
   Hecke group with respect to the cusp and flare expansions.
   That is, we split a fundamental domain into pieces in which
   a certain Fourier expansion is "best."
   A lot of the code is borrowed from Andreas Strombergsson. */

/* We assume any Hecke group is generated by z |-> z+1 and
  z |-> -r^2/z. */

  /* Author: Alex Karlovitz */

/**********************************************************************
  Special functions (from Strombergsson)
**********************************************************************/

/* See def in GR, 9.100. We sum up to and including the z^N-term.
 Chooses N by the following (completely ad hoc and sloppy heuristic)
 method: Stop when p has decreased >= 10 times in a row and |p|<re*|s|. */

hypergeom(a,b,c,z)=
{
  local(s,p,pp,n,r,re,prec);

  /* re: Desired relative error bound for hypergeom function.
     Let's make it correspond to current precision. */
  prec = default(realprecision);
  re = 10^(-prec);

  s=1;
  p=1;
  r=0;
  n=0;
  while(1,
    pp=(a+n)*(b+n)/((c+n)*(1+n))*z;
    if (abs(pp)<1, r++, r=0);
    p=p*pp;
    s+=p;
    if ((r>=10 && abs(p)<re*abs(s)), return(s););
    n++;
  );
  s;
}

/* Legendre function of the first kind, for -1<=x<=1.  */
/* See def in GR, 8.704.  */
Plegendre(mu,nu,x)=
{
  real(1/gamma(1-mu)*((1+x)/(1-x))^(mu/2)*hypergeom(-nu,nu+1,1-mu,(1-x)/2));
}

/**********************************************************************
  Whittaker functions
**********************************************************************/

/* Whittaker function in the cuspidal expansion */
cusp_Whitt(y, m, nu)=
{
  sqrt(y)*real(besselk(nu, 2*Pi*m*y));
}

/* Whittaker function in the flare expansion */
flare_Whitt(thet, m, s, kappa)=
{
  sqrt(sin(thet))*Plegendre(0.5-s, -0.5+2*Pi*m*I/log(kappa), cos(thet));
}

/* Whittaker function in the Fourier expansion in disk model */
disk_Whitt(rho, m, s)=
{
  (1 - rho^2)^s*rho^abs(m)*hypergeom(s, s + abs(m), 1 + abs(m), rho^2);
}

/**********************************************************************
  Hecke group functions
**********************************************************************/

/*
Pullback to fundamental domain |z| >= r and 0 <= Re(z) <= 1
*/
pullback_Hecke(z, r)=
{
  local(x, H);

  while(1,
  /* Find integer H such that -1/2 <= Re(z) + H <= 1/2.  */
    x = real(z);
    if(x < 0.5,
      H = truncate(0.5-x); z=z+H;,
      H = truncate(x+0.5); z=z-H;
    );
    if((real(z)^2 + imag(z)^2 >= r^2),
      if(real(z)<0,
        return(z+1),
        return(z)
      );,
      z=-r^2/z;
    );
  );
}

/*
Map from flare domain to original domain
*/
hyp_to_true(r, th, rho) =
{
  local(w,z1,z2,c);

  z1=(1/2)*(1-sqrt(1-4*r^2));   z2=(1/2)*(1+sqrt(1-4*r^2));
  c=(r-z2)/(r-z1);
  w=rho*exp(th*I);
  (z2*w-c*z1)/(w-c);
}

/*
Map from original domain to flare domain
*/
true_to_hyp(r, z)=
{
  local(w,z1,z2,c);

  z1=(1/2)*(1-sqrt(1-4*r^2));   z2=(1/2)*(1+sqrt(1-4*r^2));
  c=(r-z2)/(r-z1);
  w=c*(z-z1)/(z-z2);
  [abs(w),arg(w)];
}

/*
Creates set of N test points at height Y in [0, 1/2).
  - Evenness of base eigenfunction means we only need half a horocycle.
*/
test_points_horocycle(N, Y) =
{
  local(zs);

  zs = vector(N);
  for(j = 1, N, zs[j] = (j-1)/(2*(N)) + Y*I);
  return(zs);
}

/*
Creates set of N test points which are pullbacks of a ray of angle alpha
in the flare domain.
  - Want pullbacks since all our functions assume points are in original domain.
  - r is the Hecke group parameter (needed for pullback).
  - Ray out from the origin; points have norm between 1 and sqrt(kappa).
    - Evenness of base eigenfunction means we only need half a full range.
*/
test_points_ray(N, r, kappa, alpha) =
{
local(zs);

zs=vector(N);
for(j = 1, N, zs[j] = hyp_to_true(r, alpha, exp(j/(2*N)*log(kappa))));
return(zs);
}

/*
Creates set of test points as in Strombergsson's program.
  - r - Hecke group parameter
  - Y - height for test points in original fundamental domain
  - alpha - angle for test point in flare domain
  - N1 - will take N1 test points in original fundamental domain
  - N2 - will take N2 test points in flare domain
*/
test_points_Stromb(r, Y, N1, alpha, N2) =
{
  local(kappa, zs, zs1, zs2);

  /* kappa is the scaling parameter for the flare */
  kappa = ((1+sqrt(1-4*r^2))/(2*r))^2;

  /* Take M+2 points from a horocycle at height Y */
  zs1 = test_points_horocycle(N1, Y);

  /* Take 2*MM points from a ray in the flare domain at angle alpha */
  zs2 = test_points_ray(N2, r, kappa, alpha);

  /* Return all N1 + N2 points */
  zs = concat(zs1, zs2);
  return(zs);
}

/*
Creates N test points at height Y with x-values between x1 and x2
*/
test_points_horiz(N, Y, x1, x2)=
{
  local(zs);

  zs = vector(N);
  for(j = 1, N, zs[j] = x1 + (x2 - x1)*(j-1)/N + Y*I);
  return(zs);
}

/**********************************************************************
  Linear algebra algorithm (from Strombergsson)
**********************************************************************/

/*
 To utilize as much information as possible, we will typically be looking
 at a linear system with more equations than variables. In particular, we
 have a system of the type "A*x=0", where x is the sought for M-dimensional
 vector of Fourier coefficients, and A is an N*M-matrix where N>=M-1
 is the number of given points. Of course, since typically N should be
 much larger than M, it will be impossible to find an EXACT solution x
 to "A*x=0". Instead we seek x so as to MINIMIZE |A*x| (Euclidean norm).
 for some given normalization of x. Perhaps the most natural normalization
 of x would be |x|=1; however here we instead normalize by setting
 x[1]=1. Thus, since |A*x|^2=x^t*AA*x with AA:=A^t*A (an M*M-matrix), it
 turns out that we wish to find that vector x which satisfies x[1]=1 and
 AA'*x=0, where AA' is the (M-1)*M-matrix obtained by removing the top row
 from AA. We find this vector x using Gauss elimination, via solve_sys.
*/

/*
 The following routine solves a linear system of equations using
 Gauss elimination. Of course we could instead have tried to make
 use of some built-in PARI routine, but we wanted to have maximal
 control. Actually the routine below is a very downscaled version
 of a much longer routine, which e.g. allows a higher dimensional
 solution space (e.g. when looking for holomorphic modular forms)
 and also allows some "tricks", e.g. to have available more
 equations than are actually used in the end, so that in each new
 j-iteration we seek among more than one row to find a good pivot.
 (This is probably humbug to any expert in numerical linear algebra,
 but it has been found to work well in practice when dealing with a
 higher dimensional space of holomorphic modular forms.) Anyway,
 I have taken this away below since I doubt it would be useful for
 the problem we are now discussing.)
*/

/*
 Solve the homogeneous system of equations whose coefficients are
 given by AA using Gauss elimination.
 cfree is the index of the column which should be kept as a free variable.
*/
solve_sys(AA, cfree)=
{
  local(Nequ, Nu, c, maxc, maxk, columninfo, j, k, A, N, jj);

  /* get number of equations and variables */
  Nequ = matsize(AA)[2];
  Nu = matsize(AA[1])[2];

  /* We maintain  columninfo  so that
    columninfo[k] = j   if column k has been used as pivot column and
                          the corresponding "1" is in row j.
                  = -1  if column k has not yet been used as pivot. */
  columninfo=vector(Nu,k,-1);

  /* loop through rows */
  for(j=1,Nequ,
    /* Find the coefficient of largest absolute value in row number j. */
    maxc=0; maxk=-1;
    for(k=1,Nu, if((k!=cfree),
      c=abs(AA[j][k]); if((c>maxc), maxk=k; maxc=c;);
    ););
    if((maxk==-1), error("In solveequsyst; unexpected linear dependence "j););

    /* Divide all coefficients in row j  with  AA[j,maxk]. */
    A=1/AA[j][maxk];
    AA[j]=A*AA[j];
    AA[j][maxk]=1;    /* EXACT 1, not "1.000000000023", say! */

    /* Update columninfo. */
    columninfo[maxk]=j;

    /* Subtract row j from all other rows. */
    for(N=1,Nequ,
      if(N != j,
        A=AA[N][maxk];
        AA[N] = AA[N]-A*AA[j];
        AA[N][maxk]=0;   /* EXACT 0, not "0.0E-10", say! */
      );
    );
  );

  /* Return the solution vector. */
  vector(Nu, k, if(k==cfree, 1, -AA[columninfo[k]][cfree]));
}

/**********************************************************************
  Code for setting up and solving linear system
**********************************************************************/

/*
Sets up matrix of equations for list of test points z
  - use both cusp and flare expansions
    - if test point is in fundamental domain, compare two expansions
    - else, compare expansions at test point to those at pullback
  - r - Hecke group parameter
  - lambda = s(1 - s)
  - only use cuspidal expansion if test point has height >= y0
  - only use flare expansion if test point has argument <= alpha0
  - M - number of nonzero coefficients to take in cuspidal expansion
  - MM - number of nonzero coefficients to take in flare expansion
  - scale_flare - 1 if we want to scale flare coefficients for stability
*/
init_eqns_cusp_and_flare(z, r, s, y0, M, alpha0, MM, scale_flare)=
{
  local(num_eqns, j, zz, zjrth, zzrth, kappa, zrepr, jjj, m, a, B);

  /* kappa is the scaling parameter for the flare */
  kappa = ((1+sqrt(1-4*r^2))/(2*r))^2;

  /* every point in the vector z may give one or two equations
     - rows of A correspond to equations
     - cols correspond to coefficients
       - cols 1, ..., M+1 are for cuspidal expansion
       - cols M+2,..., M+MM+2 are for flare expansion */
  A = vector(2*length(z), x, vector(M+MM+2));

  /* loop through all test points, keeping track of how many equations */
  num_eqns = 1;
  for(j = 1, length(z),
    /* get pullback, then corresponding flare domain points */
    zz = pullback_Hecke(z[j],r);
    zjrth = true_to_hyp(r,z[j]);
    zzrth = true_to_hyp(r,zz);

    /* Number of ways to represent z[j]; 1 or 2! */
    zrepr = 0;

    /* if z is admissible wrt cusp, save those coefficients */
    if(imag(z[j]) >= y0,
      A[num_eqns][1] = imag(z[j])^(1-s);
      for(m=1, M, A[num_eqns][m+1] = cusp_Whitt(imag(z[j]), m, s - 0.5)*cos(2*Pi*m*real(z[j])););
      zrepr=1;
    );

    /* if z is admissible wrt flare, save those coefficients */
    if(zjrth[2] <= alpha0,
      for(m=0, MM, A[num_eqns+zrepr][M+2+m] = flare_Whitt(zjrth[2], m, s, kappa)*cos(2*Pi*m*log(zjrth[1])/log(kappa)) );
      if(scale_flare == 1,
        for(m=0, MM, A[num_eqns+zrepr][M+2+m] /= exp(2*Pi^2*m/log(kappa)));
      );
      zrepr++;
    );

    /* now use one equation if pullback is same as test point, otherwise two */
    if(abs(zz-z[j]) < 1e-10,

      /* Got here if test point is in fundamental domain */
      if(zrepr!=2, error("Point "j" "z[j]" in fundamental domain and inadmissible!"));
      for(m=0, MM, A[num_eqns][M+2+m] = -A[num_eqns+1][M+2+m];);
      zrepr = 1;
      ,

      /* If test point is not in fundamental domain, use cusp expansion for pullback if admissible */
      if(imag(zz) >= y0,
        for(jjj = 0, zrepr-1, A[num_eqns+jjj][1] -= imag(zz)^(1-s));
        for(m = 1, M,
          a = cusp_Whitt(imag(zz), m, s - 0.5)*cos(2*Pi*m*real(zz));
        for(jjj = 0, zrepr-1, A[num_eqns+jjj][m+1] -= a);
        );
      ,

        /* Otherwise, use flare expansion for pullback if admissible */
        if(zzrth[2] > alpha0, error("Pullback "zz" not ok for any expansion!"));
        for(m = 0, MM,
          a = flare_Whitt(zzrth[2], m, s, kappa)*cos(2*Pi*m*log(zzrth[1])/log(kappa));
          if(scale_flare == 1,
            for(jjj = 0, zrepr-1, A[num_eqns+jjj][M+2+m] -= a/exp(2*Pi^2*m/log(kappa))),
            for(jjj = 0, zrepr-1, A[num_eqns+jjj][M+2+m] -= a)
          );
        );
      );
    );
    num_eqns += zrepr;
  );
  /* return matrix, but only use rows which got an equation filled in */
  num_eqns = num_eqns-1;
  B = matrix(num_eqns, M+MM+2, k, j, A[k][j]);
  return(B);
}

/*
Given a set of test points z, set up and solve linear system for the Fourier
coefficients. Assumes we are working with an infinite volume Hecke group.
  - r - Hecke group parameter
  - s - assumed eigenvalue is lambda = s(1 - s)
  - only use cuspidal expansion if test point has height >= y0
  - only use flare expansion if test point has argument <= alpha0
  - M - number of nonzero coefficients to take in cuspidal expansion
  - MM - number of nonzero coefficients to take in flare expansion
  - scale_flare - 1 if we want to scale flare coefficients for stability
*/
least_square_method_cusp_and_flare(z, r, s, y0, M, alpha0, MM, scale_flare) =
{
  /* double check that group has infinite volume */
  if(r >= 1, error("Group must have infinite volume to use flare expansion."));

  local(k, A, AA, B, x);

  /* Set up matrix of equations */
  A = init_eqns_cusp_and_flare(z, r, s, y0, M, alpha0, MM, scale_flare);

  /* Use Strombergsson's method for least squares */
  AA = mattranspose(A)*A;
  B = vector(M+MM+1, k, vector(M+MM+2, j, AA[k+1, j]));
  x = solve_sys(B, 1);

  /* return Fourier coefficient vector */
  return(x);
}

/**********************************************************************
  Actual loops for Hejhal's algorithm
**********************************************************************/

/*
Runs a "secant method version" of Hejhal's algorithm (learned from
Strombergsson)
  - r - Hecke group parameter
  - we only use cuspidal expansion when test point has height >= y0
  - we only use flare expansion when test point has argument <= alpha0
  - M1 = number of points taken in cuspidal expansion
  - M2 = number of points taken in flare expansion
  - s = starting guess
  - delta = starting step size away from guess
  - scale_flare - 1 if we want to scale flare coefficients for stability
*/
secant_method(z1, z2, r, y0, alpha0, M1, M2, s, delta, scale_flare)=
{
  local(s_new, c1, c2, j, s_max, s_min, s_mid, delta_new);

  s_new=vector(4);

  while(1,

    /* Get differences of some Fourier coefficients for s */
    x1 = least_square_method_cusp_and_flare(z1, r, s, y0, M1, alpha0, M2, scale_flare);
    x2 = least_square_method_cusp_and_flare(z2, r, s, y0-0.02, M1, alpha0+0.05, M2, scale_flare);
    c1 = [x1[2] - x2[2], x1[3] - x2[3], x1[M1+2] - x2[M1+2], x1[M1+3] - x2[M1+3]];

    /* Now do the same for s + delta */
    x1 = least_square_method_cusp_and_flare(z1, r, s+delta, y0, M1, alpha0, M2, scale_flare);
    x2 = least_square_method_cusp_and_flare(z2, r, s+delta, y0-0.02, M1, alpha0+0.05, M2, scale_flare);
    c2 = [x1[2] - x2[2], x1[3] - x2[3], x1[M1+2] - x2[M1+2], x1[M1+3] - x2[M1+3]];

    /* Run one iteration of secant method on each difference */
    s_max = 0.0; s_min = 100.0;
    for(j = 1, 4,
      s_new[j] = (c1[j]*(s+delta) - c2[j]*s)/(c1[j] - c2[j]);
      s_max = max(s_max, s_new[j]);
      s_min = min(s_min, s_new[j]);
    );
    s_mid = 0.5*(s_max + s_min);

    /* Ad hoc check if it's worth continuing */
    delta_new = (s_max - s_min)*5;
    if(delta_new > 0.5*delta,
      print("Approximate error:"s_max - s_min);
      print("Prediction:"s_mid);
      return([s_mid, x1]);
    );
    delta = delta_new;
    s = s_mid-0.5*delta;
  );
}

/*
Use Hejhal's original zoom in method: search for s in a grid of points,
then look at continually finer grids at best test points.
Get best based on minimum error in Fourier coefficients between two
sets of test points.
*/
grid_zoom_in(r, alpha0, y0, M, MM, s_start, grid_size_start, num_steps)=
{
  local(best_s, grid_size, s_list, error_list, R, idx);

  /* get two sets of test points at which to compare linear systems */
  z1 = test_points_Stromb(r, y0, M, alpha0, MM);
  z2 = test_points_Stromb(r, y0-0.02, M, alpha0+0.05, MM);

  best_s = s_start;
  grid_size = grid_size_start;

  /* repeat process for num_steps */
  for(i = 1, num_steps,
    /* print best s so far */
    print("Current guess: s = "best_s);

    /* get list of guesses */
    s_list = vector(11, n, best_s - 5*grid_size + (n-1)*grid_size);
    error_list = vector(11, n, 0);

    /* loop through grid of s values */
    for(j = 1, 11,
      /* get two sets of coefficients  and store error */
      x1 = least_square_method_cusp_and_flare(z1, r, s_list[j], y0, M, alpha0, MM, scale_flare);
      x2 = least_square_method_cusp_and_flare(z2, r, s_list[j], y0-0.02, M, alpha0+0.05, MM, scale_flare);
      error_list[j] = norml2(x1 - x2);
    );

    /* print list of s values and corresponding errors */
    /*print("s guesses: "s_list);
    print("errors: "error_list);*/

    /* get s with minimum error to search near */
    vecmin(error_list, &idx);
    best_s = s_list[idx];

    /* update grid size */
    grid_size = grid_size*0.1;
  );

  return(best_s);
}
