
/*  fourier2.pari            */

/**********************************************************************
  Special functions
**********************************************************************/

/* Associated Legendre function of the first kind. */

/* See def in GR, 9.100. We sum up to and including the z^N-term.  */
/* Compare with Maple  "hypergeom([a,b],[c],z);"!  */
hypergeom(a,b,c,z,N)=
{
  local(s,p,n);

  s=1;
  p=1;
  for(n=0,N-1,
    p=p*(a+n)*(b+n)/((c+n)*(1+n))*z;
    s+=p;
  );
  s;
}


/* Slightly better routine for the same task:
 Chooses N by the following (completely ad hoc and sloppy heuristic)
 method: Stop when p has decreased >= 10 times in a row and |p|<re*|s|.
*/

/* Global variable  re: Desired relative error bound for hypergeom function. */

re=1e-50;

hypergeom2(a,b,c,z)=
{
  local(s,p,pp,n,r);

/*  default(realprecision,80);
  a=precision(a,80);
  b=precision(b,80);
  c=precision(c,80);
  z=precision(z,80);   */
  s=1;
  p=1;
  r=0;
  n=0;
  while(1,
    pp=(a+n)*(b+n)/((c+n)*(1+n))*z;
    if (abs(pp)<1, r++, r=0);
    p=p*pp;
    s+=p;
    if ((r>=10 && abs(p)<re*abs(s)), return(s););
    n++;
  );
/*   default(realprecision,40);  */
  s;
}

/* Legendre function of the first kind, for -1<=x<=1.  */
/* See def in GR, 8.704.  */
Plegendre(mu,nu,x,N)=
{
  1/gamma(1-mu)*((1+x)/(1-x))^(mu/2)*hypergeom(-nu,nu+1,1-mu,(1-x)/2,N);
}

Plegendre2(mu,nu,x)=
{
  local(a);
  real(1/gamma(1-mu)*((1+x)/(1-x))^(mu/2)*hypergeom2(-nu,nu+1,1-mu,(1-x)/2));
}


/*********************************************************************
  Printing...
**********************************************************************/

printwithformat(s,a)=
{
  local(rp);

/* It seems that   "default(format,***)"  changes the default
   realprecision! Isn't this weird?    */
  rp=default(realprecision);
  default(format,s);
  print1(a);
  default(realprecision,rp);
}




/**********************************************************************
 Pullback algorithm, and related stuff.

 We define GAMMA_r to be the Fuchsian group generated by
   z --> z+1   and   z --> r^2/z.
 We choose the following fundamental domain (NOT same as in fourier1.pari!)
   F={z=x+iy | 0 < x < 1, |z|>r, |z-1|>r};

 Note that the map  T = [1/r,-r; 1/r,0]=[1,1;0,1]*[0,-r,1/r,0] lies in
 GAMMA_r; this is a hyperbolic map (since r<1/2) and its axis is the
 geodesic C between
   z1=(1/2)*(1-sqrt(1-4*r^2))  and  z2=(1/2)*(1+sqrt(1-4*r^2)).
 Note that both the geodesics  {|z|=r}  and  {|z-1|=r}  are orthogonal
 to C, and  T  maps  {|z|=r}  to  {|z-1|=r}. Hence for any hypercycle
 C(h) from z1 to z2 and lying "below" C, the region below C(h) and
 inside {|z|>r, |z-1|>r} is a "flare". To be specific: For any real
 number h we define C(h) to be the Euclidean circle arc between z1 and z2
 with (Euclidean) circle center (1/2)-h*I; then C(h) lies "below" C
 if and only if h>0, and our flare described above has parameter
 alpha = (Pi/2)-arctan(h/sqrt(1/4-r^2)).
 (Thus: h = sqrt(1/4-r^2)*tan(Pi/2-alpha).)
 Our flare is mapped to the standard hyperbolic domain F(alpha) by the
 map  U(z) := c*(z-z1)/(z-z2), where c=(r-z2)/(r-z1)<0.
 Note U(z1)=0, U(z2)=oo, U(r)=1, U(-r)=-1, as it should be.
 Also the kappa-parameter of our flare is given by (we use Alex notation,
 so that F(alpha)={z : 1<|z|<kappa, 0<arg(z)<alpha}, and NOT Gamburd's
 notation with exp(kappa) in place of kappa):
   kappa=U(1-r)=(z2/r)^2  and  U(1+r)=-kappa.
 Note that, of course, kappa is the multiplier of T, and thus
   tr(T)=1/r=kappa^(1/2)+kappa^(-1/2).

For our computations we fix once and for all some h0>0 and consider the
region of points below C(h0) and inside {|z|>r, |z-1|>r} to be our
"basic flare", F(alpha0). Note that F(alpha0) is completely contained
in our fundamental domain F, and the infimum of Im(z) for z in F-F(alpha0)
is y0=infheight(r,h0)  (see function below).

Using the fact that our sought for eigenfunction is even wrt reflection
in the geodesic Re(z)=1/2 (and also using that n and -n give the
same P_nu^mu(x)) it follows that c_n=c_{-n} in the hyperbolic expansion),
i.e. the hyperbolic expansion can be written:

 sum_{n=0..MM} c_n sqrt(sin(theta)) P_nu^mu(cos theta)
                                     cos(2 pi n log(rho)/log(kappa))

We use M as cutoff of Fourier expansion at the cusp, and MM as cutoff
for the hyperbolic expansion. Thus in our equation system, column
j for 1<=j<=M+1 concerns cusp Fourier coefficient a_{j-1},
and column j for M+2<=j<=M+2+MM concerns hyperbolic Fourier coefficient
c_{j-M-2}.
**********************************************************************/


infheight(r,h)=
{
  (sqrt(4*h^2+1-4*r^2)-4*h*r)*r/(4*h^2+1);
}

infheight2(r,alpha)=
{
  infheight(r,sqrt(1/4-r^2)*tan(Pi/2-alpha));
}

hyptotrue(r,th,rho) =
{
  local(w,z1,z2,c);

  z1=(1/2)*(1-sqrt(1-4*r^2));   z2=(1/2)*(1+sqrt(1-4*r^2));
  c=(r-z2)/(r-z1);
  w=rho*exp(th*I);
  (z2*w-c*z1)/(w-c);
}

truetohyp(r,z)=
{
  local(w,z1,z2,c);

  z1=(1/2)*(1-sqrt(1-4*r^2));   z2=(1/2)*(1+sqrt(1-4*r^2));
  c=(r-z2)/(r-z1);
  w=c*(z-z1)/(z-z2);
  [abs(w),arg(w)];
}

/*
   Find the (GAMMA_r-)pullback of z to the (standard) fundamental
   domain of GAMMA_r.
*/
pullback(z,r)=
{
  local(x,H);

  while(1,
/* Find integer H such that -1/2 <= Re(z) + H <= 1/2.  */
    x=real(z);
    if (x<0.5, H = truncate(0.5-x); z=z+H; , H = truncate(x+0.5); z=z-H;);
    if ((real(z)^2 + imag(z)^2>r^2-1e-8), return(z); , z=-r^2/z; );

/* The "-1e-8" in the above test is to ensure that we do not enter an
   infinite loop for points extremely close the circle |z|=r.   */

  );
}


/*
   NEW, for 2-expansions! Fundamental domain with 0<=Re(z)<1 !
*/
pullback2(z,r)=
{
  local(x,H);

  while(1,
/* Find integer H such that -1/2 <= Re(z) + H <= 1/2.  */
    x=real(z);
    if (x<0.5, H = truncate(0.5-x); z=z+H; , H = truncate(x+0.5); z=z-H;);
    if ((real(z)^2 + imag(z)^2>r^2-1e-8),
      if(real(z)<0,return(z+1), return(z));
                     /* The only diff vs old pullback! */
    ,
      z=-r^2/z;
    );

/* The "-1e-8" in the above test is to ensure that we do not enter an
   infinite loop for points extremely close the circle |z|=r.   */

  );
}



/**********************************************************************
   Hejhal's method

 This method was introduced by Hejhal in his 1999 paper
 "On Eigenfunctions of the Laplacian for Hecke Triangle Groups";
 it builds on the basic methods of setting up the linear relation
 "f(z)=f(pullback(z))" for several choices of z; however it makes
 the very special choice of the z-points as an equidistributed set
 of points along a closed horocycle lying below the fundamental
 domain, and then chooses special linear combinations of the above
 equation; linear combinations which "sieve" out a single Fourier
 coefficient.. This system turns out to be particularly robust e.g.
 in the large-eigenvalue aspect. See the above-mentioned paper for
 details, or my paper with Booker and Venkatesh.
 The procedure  inithejhalequations  below sets up Hejhal's linear
 system.

 HOWEVER, I DON'T think this method is of any advantage for the
 problem we wish to solve, compared to the more "down to earth"
 linear algebra method of  just recording the equations
 "f(z)=f(pullback(z))" themselves.
 Thus I guess you may just skip the following, all the way down to
 "more direct linear algebra method(s)" below!
**********************************************************************/

hejhalmethod(r,R,M,Q,Y)=
{
  local(x1,x2,j);

  inithejhalequations(r,R,M,Q,Y);
  x1=solveequsyst(M-1,M,1);
  inithejhalequations(r,R,M,Q,Y-0.03);
  x2=solveequsyst(M-1,M,1);
  print("n  c[n]  error");
  for(j=1,M,
    default(format,"f0.28");
    print1(j"  "x1[j]"  ");
    default(format,"e0.5");
    print(abs(x1[j]-x2[j]))
/*
 Note: The difference   abs(x1[j]-x2[j])  is a CRUDE indication of
 the absolute error in the coefficient obtained!
*/
  );
  default(format,"g0.28");
}

/*
 Find  M  such that replacing the infinite Fourier series the FINITE
 sum from 1 to M can be expected to cause absolute error < prec
 for all z=x+iy with y>=Y.

 Of course this routine only gives a crude, very simple guess!
 (For example it is assumed here that all Fourier coefficients will have
 size "around 1".)
*/
findgoodcutoffM(R,Y,prec)=
{
  m=1;
  while(abs(exp(R*Pi/2)*real(besselk(I*R,2*Pi*m*Y)))>0.01*prec, m++);

/* Explanation: The size of besselk(I*R,y) for "all y before the range
   of exponential decay" is, very roughly, ~ exp(-R*Pi/2).   */

  return(m+1);
}

inithejhalequations(r,R,M,Q,Y) =
{
  local(A,m,z,zz,C,CC,j,k,g,summa,f,ch);

/* Initialize global variable "equc", to contain the coefficients of our
   system of equations. Note that the following automatically sets all
   equc[j][k] to 0.   */

  equc = vector(M,x,vector(M));

/* Initialize auxiliary vector A. */
  A = vector(M);

  for(m=1-Q,0,
    z=0.5*(m-0.5)/Q + I*Y;
    zz=pullback(z,r);
    C=0.5/Q;
    for(j=1,M,
      A[j]= 2.0*sqrt(imag(zz)) * real(besselk(I*R,2*Pi*j*imag(zz))) * cos(2*Pi*j*real(zz));
    );
/* Inside the following loop we keep  CC=2*C*exp(-I*2*Pi*k*real(z)). */
    g=exp(-I*2*Pi*real(z));
    CC=2.0*C*g;
    for(k=1,M,
      for(j=1,M,
        equc[k][j]=equc[k][j]+real(CC*A[j]);
      );
      CC=CC*g
    );
  );
  C=sqrt(Y);
  for(k=1,M,
    equc[k][k]=equc[k][k] - C * real(besselk(I*R,2*Pi*k*Y));
  );
}

computefouriercoeffs(M,Q,Y,Fvals,R) =
{
  local(a,m,s,ss,j);
  if (imag(R)!=0, s=0.5-imag(R);, s=0.5+I*R;);
  if (length(Fvals)!=2*Q, error("Wrong Fvals length! "length(Fvals)" "Q));
  a=vector(M+1);
  for(m=0,M,
    ss=sum(j=0,2*Q-1,Fvals[j+1]*cos(2*Pi*m*(j-Q+0.5)/(2*Q)));
    if(m==0,
       a[1]=ss/(2*Q*Y^(1-s));
    ,
       a[m+1]=ss/(2*Q*sqrt(Y)*real(besselk(I*R,2*Pi*m*Y)));
    );
  );
  a;
}

computehypfouriercoeffs(M,Q,th,Fvals,R,r,writeflag) =
{
  local(a,m,s,ss,j,z2,kappa);
  z2=(1/2)*(1+sqrt(1-4*r^2));
  kappa=(z2/r)^2;
  if (imag(R)!=0, s=0.5-imag(R);, s=0.5+I*R;);
  if (length(Fvals)!=Q, error("Wrong Fvals length! "length(Fvals)" "Q));
  a=vector(M+1);
  for(m=0,M,
    ss=(1/Q)*sum(j=0,Q-1,Fvals[j+1]*cos(2*Pi*m*j/Q));
    if(writeflag, print(m"  "ss));
    a[m+1]=ss/(sqrt(sin(th))*Plegendre2(0.5-s,-0.5+2*Pi*m*I/log(kappa),cos(th)));
  );
  a;
}

testexplfouriercoeffsvec(z)=
{
  local(j,ans,zz,ans1);
  for(j=1,length(z),
    ans=testexplfouriercoeffs(z[j]);
    zz=pullback2(z[j]);
    ans1=[];
    if (abs(zz-z[j])>1e-10, ans1=testexplfouriercoeffs(zz););
    print(z[j]"  "ans"  "ans1);
  );
}

testexplfouriercoeffs(z)=
{
  local(r,R,z2,kappa,ccusp,chyp,ans,ss,m,zrth,ccc);

  ccc=1.033151741564709576200942471;
  r=0.35;
  R=-I*(0.76574757-0.5);
  z2=(1/2)*(1+sqrt(1-4*r^2));
  kappa=(z2/r)^2;
  if (imag(R)!=0, s=0.5-imag(R);, s=0.5+I*R;);
  ccusp=[1.0,0.6935,0.517,0.205,0.0,0.04,0.25];
  chyp=[0.56895,-0.000042827,1.28e-10,-1.04e-14,1.5e-19];
  ans=[];
  if (imag(z)>=0.34,
    ss=imag(z)^(1-s);
    for(m=1,length(ccusp)-1, ss+=ccusp[m+1]*sqrt(imag(z))*real(besselk(I*R,2*Pi*m*imag(z)))*2*cos(2*Pi*m*real(z)));
    ans=[ss];
  );
  zrth=truetohyp(r,z);
  if(zrth[2]<=2.3,
    ss=0.0;
    for(m=0,length(chyp)-1,ss+=chyp[m+1]*sqrt(sin(zrth[2]))*Plegendre2(0.5-s,-0.5+2*Pi*m*I/log(kappa),cos(zrth[2]))*(if(m>=1,2,1))*cos(2*Pi*m*log(zrth[1])/log(kappa)));
    if(length(ans)>0, ans=[ans[1],ss], ans=[ss]);
  );
  ccc*ans;
}


/*
 The following routine solves a linear system of equations using
 Gauss elimination. Of course we could instead have tried to make
 use of some built-in PARI routine, but we wanted to have maximal
 control. Actually the routine below is a very downscaled version
 of a much longer routine, which e.g. allows a higher dimensional
 solution space (e.g. when looking for holomorphic modular forms)
 and also allows some "tricks", e.g. to have available more
 equations than are actually used in the end, so that in each new
 j-iteration we seek among more than one row to find a good pivot.
 (This is probably humbug to any expert in numerical linear algebra,
 but it has been found to work well in practice when dealing with a
 higher dimensional space of holomorphic modular forms.) Anyway,
 I have taken this away below since I doubt it would be useful for
 the problem we are now discussing.)
*/


/*  solveequsyst:
 Solve the homogeneous system of equations whose coefficients are
 given by  equc  (global variable), using Gauss elimination.
 Nequ is the number of equations, and Nu is the number of unknowns.
 free  is a the index of the column which should be kept as a "free
  variable".
*/
solveequsyst(Nequ,Nu,cfree)=
{
  local(c,maxc,maxk,columninfo,j,k,A,N,jj);

  columninfo=vector(Nu,k,-1);
/* We maintain  columninfo  so that
   columninfo[k] = j   if column k has been used as pivot column and
                        the corresponding "1" is in row j.
                 = -1  if column k has not yet been used as pivot.
*/

  for(j=1,Nequ,
/* Find the coefficient of largest absolute value in row number j. */
    maxc=0; maxk=-1;
    for(k=1,Nu, if((k!=cfree),
      c=abs(equc[j][k]); if((c>maxc), maxk=k; maxc=c;);
    ););
    if((maxk==-1), error("In solveequsyst; unexpected linear dependence "j););
/* Divide all coefficients in row j  with  equc[j,maxk]. */
    A=1/equc[j][maxk];
    equc[j]=A*equc[j];
    equc[j][maxk]=1;    /* EXACT 1, not "1.000000000023", say! */
/* Update columninfo. */
    columninfo[maxk]=j;
/* Subtract row j from all other rows. */
    for(N=1,Nequ, if(N != j,
      A=equc[N][maxk];
      equc[N] = equc[N]-A*equc[j];
      equc[N][maxk]=0;   /* EXACT 0, not "0.0E-10", say! */
/*      if ((j<5 && N<5),
        print("prec "j" "N":::"precision(equc[N]));
        print("prec "j" "N":::"vector(16,jj,precision(equc[N][jj])));
      ); */
    ););
  );

/* Return the solution vector. */
  vector(Nu,k,if(k==cfree,1,-equc[columninfo[k]][cfree]));
}



/**************************************************************************
  More direct linear algebra method(s):
  We consider directly the system of equations coming from the relations
   "f(z)=f(pullback(z))",  where z runs through some set of points.

  There are two main routines below:

  primitivelinalgmethod - uses exactly M-1 points z, where M is the number
                          of Fourier coefficients we are solving for.

  leastsquaremethod - Here we may use as many points as we like, for fixed M;
                      and we seek the vector [c1,c2,...,c_M] which is
                      closest to satisfying ALL relations, in a least square
                      sense.
**************************************************************************/

/*
 Solve the linear system for two sets of points, zset1 and zset2;
 here we assume that both zset1 and zset2 contain exactly M-1 points
 (they may actually contain MORE than M-1 points, but only the
 first M-1 points are used when solving the linear system).

 Ncs = The number of "constant terms" we allow in the Fourier expansion.
  This number may be 0,1 or 2. If Ncs=1 then we assume that the constant
  term is  x[1]*y^(1/2-I*R);  if  Ncs=2 then we assume that it is
   x[1]*y^(1/2-I*R) + x[2]*y^(1/2+I*R).
*/
primitivelinalgmethod(r,R,zset1,zset2,M,Ncs) =
{
  local(x1,x2,j,eflag,ecoeff);

  initzequations(r,R,zset1,M,Ncs);
  x1=solveequsyst(M-1,M,1);
  initzequations(r,R,zset2,M,Ncs);
  x2=solveequsyst(M-1,M,1);
/* If Ncs==2 and  r==1.0 (viz GAMMA_r=PSL(2,Z)) then we compare against
   the Eisenstein series.   */
  if((Ncs==2 && abs(r-1.0)<1E-15),
    eflag=1;
    ecoeff=ecoeffdirect(1/2+I*R,M);
    print("n  c[n]  REL.ERROR: indicator / true.");
  ,
    eflag=0;
    print("n  c[n]  error");
  );
  for(j=1,M,
    if(j<=Ncs,if(j==Ncs, print1(0" (y^(1-s))"), print1(0" (y^s)")), print1(j-Ncs));
    if (eflag,
      default(format,"f0.20");
      print1("  "x1[j]"  ");
      default(format,"e0.3");
      print(abs((x1[j]-x2[j])/x1[j])"  "abs((x1[j]-ecoeff[j])/x1[j]));
   ,
      default(format,"f0.28");
      print1("  "x1[j]"  ");
      default(format,"e0.5");
      print(abs(x1[j]-x2[j]))
    );
  );
  default(format,"g0.28");
}

/*
 Here let the M-1 points be evenly spread along the horocycle segment
 between -0.5+Y*I and Y*I; and for the second set of points take the
 corresponding points at height Y-0.03. Note that this should give,
 "up to linear algebra transformations",  EXACTLY  the same linear
 system as   hejhalmethod(r,R,M,M,Y)
 (or something similar - I haven't thought through in detail now).
*/
primitivelinalgmethod_horo(r,R,Y,M,Ncs) =
{
  primitivelinalgmethod(r,R,zset([[M-1,[-0.5,0.0],Y]]),zset([[M-1,[-0.5,0.0],Y-0.03]]),M,Ncs);
}


/*
 Here zset1 and zset2 may contain ANY number of points (but they should
 contain at least M-1 points each, otherwise we will surely run into
 linear dependence). For each set of points zset1 and zset2, we set up
 the linear system coming from ALL the given points; thus this will be
 a system of the type   "A*x=0", where x is the sought for M-dimensional
 vector of Fourier coefficients, and A is an N*M-matrix where N>=M-1
 is the number of given points. Of course, since typically N should be
 much larger than M, it will be impossible to find an EXACT solution x
 to "A*x=0". Instead we seek x so as to MINIMIZE |A*x| (Euclidean norm).
 for some given normalization of x. Perhaps the most natural normalization
 of x would be |x|=1; however here we instead normalize by setting
 x[1]=1. Thus, since |A*x|^2=x^t*AA*x with AA:=A^t*A (an M*M-matrix), it
 turns out that we wish to find that vector x which satisfies x[1]=1 and
 AA'*x=0, where AA' is the (M-1)*M-matrix obtained by removing the top row
 from AA. We find this vector x using Gauss elimination, via solveequsyst.
*/
leastsquaremethod(r,R,zset1,zset2,M,Ncs) =
{
  local(A,AA,k,j,x1,x2,ecoeff,eflag);

  initzequations(r,R,zset1,M,Ncs);
  A=matrix(length(zset1),M,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M-1,k,vector(M,j,AA[k+1,j]));
  x1=solveequsyst(M-1,M,1);
  initzequations(r,R,zset2,M,Ncs);
  A=matrix(length(zset2),M,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M-1,k,vector(M,j,AA[k+1,j]));
  x2=solveequsyst(M-1,M,1);
/* If Ncs==2 and  r==1.0 (viz GAMMA_r=PSL(2,Z)) then we compare against
   the Eisenstein series.   */
  if((Ncs==2 && abs(r-1.0)<1E-15),
    eflag=1;
    ecoeff=ecoeffdirect(1/2+I*R,M);
    print("n  c[n]  REL.ERROR: indicator / true.");
  ,
    eflag=0;
    print("n  c[n]  error");
  );
  for(j=1,M,
    if(j<=Ncs,if(j==Ncs, print1(0" (y^(1-s))"), print1(0" (y^s)")), print1(j-Ncs));
    if (eflag,
      default(format,"f0.20");
      print1("  "x1[j]"  ");
      default(format,"e0.3");
      print(abs((x1[j]-x2[j])/x1[j])"  "abs((x1[j]-ecoeff[j])/x1[j]));
   ,
      default(format,"f0.28");
      print1("  "x1[j]"  ");
      default(format,"e0.5");
      print(abs(x1[j]-x2[j]))
    );
  );
  default(format,"g0.28");
}

leastsquaremethod2expansions(r,R,y0,M,alpha,MM) =
{
  local(zs,j,kappa,k,A,AA,x1,x2,Ne,jj);

  kappa=((1+sqrt(1-4*r^2))/(2*r))^2;
  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+y0*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha,exp(j/(2*(MM+MM))*log(kappa))));
/*  print("TESTS:");
  testexplfouriercoeffsvec(zs); */
  Ne=initzequations2expansions(r,R,y0-0.01,zs,M,alpha+0.1,MM);
  print("Ne="Ne" M+MM+2="M+MM+2);
/*  for(jj=1,Ne, print("Precs "jj": "vector(M+MM+2,k,precision(equc[jj][k]))););*/
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  print("Precs:"vector(16,k,precision(equc[divrem(k-1,4)[1]+1][divrem(k-1,4)[2]+1])));
  print(precision(equc));
  x1=solveequsyst(M+MM+1,M+MM+2,1);

  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+(y0-0.02)*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha+0.05,exp(j/(2*(MM+MM))*log(kappa))));
/*  print("TESTS:");
  testexplfouriercoeffsvec(zs);  */
  Ne=initzequations2expansions(r,R,y0-0.03,zs,M,alpha+0.1,MM);
  print("Ne="Ne" M+MM+2="M+MM+2);
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  x2=solveequsyst(M+MM+1,M+MM+2,1);

  for(j=1,M+MM+2,
    if(j<=M+1, print1(j-1" (c) "), print1(j-M-2" (h) "));
    print1("  "x1[j]"  ");
    printwithformat("e0.5",abs((x1[j]-x2[j])/x1[j]));
    print(" ");
  );
  print("Precisions: "precision(x2[2])"  "precision(x2[M+2]));
  return([x1[2]-x2[2],x1[3]-x2[3],x1[M+2]-x2[M+2],x1[M+3]-x2[M+3]]);
}

zoomin(r,alpha,y0,M,MM,s,sdelta)=
{
  local(snew,R1,R2,c1,c2,j,smax,smin,smid,sdeltanew);

  re=0.1^default(realprecision);
  snew=vector(4);
  while(1,
    print("defaultrealprecision:"default(realprecision));
    R1=-I*(s-0.5);
    R2=-I*(s+sdelta-0.5);
    c1=leastsquaremethod2expansions(r,R1,y0,M,alpha,MM);
    c2=leastsquaremethod2expansions(r,R2,y0,M,alpha,MM);
    c1=precision(c1,default(realprecision));
    c2=precision(c2,default(realprecision));
    smax=0.0; smin=100.0;
    for(j=1,4,
      snew[j]=(c1[j]*(s+sdelta)-c2[j]*s)/(c1[j]-c2[j]);
      smax=max(smax,snew[j]);
      smin=min(smin,snew[j]);
    );
    smid=0.5*(smax+smin);
    print("New predictions:");
    for(j=1,4,print(snew[j]));
/* Worth continuing? */
    sdeltanew=(smax-smin)*5;
    if(sdeltanew>0.5*sdelta,
      print("Approximate error:"smax-smin);
      print("Prediction:"smid);
      return(smid);
    );
    sdelta=sdeltanew;
    s=smid-0.5*sdelta;
  );
}

initzequations2expansions(r,R,y0,z,M,alpha,MM)=
{
  local(s,jj,j,zz,zjrth,zzrth,kappa,zrepr,jjj,m,a,IR);

  kappa=((1+sqrt(1-4*r^2))/(2*r))^2;
  /* every point in the vector z may give one OR TWO equations. */
  equc=vector(2*length(z),x,vector(M+MM+2));
  if (imag(R)!=0, s=0.5-imag(R); IR=real(I*R);, s=0.5+I*R; IR=I*R;);
  /*print("s="s);*/
  jj=1;
  for(j=1,length(z),
    zz=pullback2(z[j],r);
    zjrth=truetohyp(r,z[j]);
/*    print(j"th point: "z[j]);
    print("rhq="log(zjrth[1])/log(kappa)" th="zjrth[2]);   */
    zzrth=truetohyp(r,zz);
    zrepr=0;   /* Number of ways to represent z[j]; 1 or 2! */
    if(imag(z[j])>=y0,
/* Fill out equation with cusp coeffs of z[j]. */
      equc[jj][1]=imag(z[j])^(1-s);
      for(m=1,M, equc[jj][m+1]=sqrt(imag(z[j]))*real(besselk(IR,2*Pi*m*imag(z[j])))*2*cos(2*Pi*m*real(z[j])););
      zrepr=1
    );
    if(zjrth[2]<=alpha,
/* Fill out another equation with hyp coeffs of z[j]. */
      for(m=0,MM, equc[jj+zrepr][M+2+m]=sqrt(sin(zjrth[2]))*Plegendre2(0.5-s,-0.5+2*Pi*m*I/log(kappa),cos(zjrth[2]))*cos(2*Pi*m*log(zjrth[1])/log(kappa)) );
      zrepr++;
    );
    if(abs(zz-z[j])<1e-10,
/* Only use ONE equation! */
      if(zrepr!=2, error("Point "j" "z[j]" fails for both expansions!"));
      for(m=0,MM, equc[jj][M+2+m]=-equc[jj+1][M+2+m];);
      zrepr=1;
    , if(imag(zz)>=y0,
      for(jjj=0,zrepr-1, equc[jj+jjj][1]-=imag(zz)^(1-s));
      for(m=1,M,
        a=sqrt(imag(zz))*real(besselk(IR,2*Pi*m*imag(zz)))*2*cos(2*Pi*m*real(zz));
        for(jjj=0,zrepr-1, equc[jj+jjj][m+1]-=a);
      );
    ,
      if(zzrth[2]>alpha, error("Pullback "zz" not ok for any expansion!"));
      for(m=0,MM,
        a=sqrt(sin(zzrth[2]))*Plegendre2(0.5-s,-0.5+2*Pi*m*I/log(kappa),cos(zzrth[2]))*cos(2*Pi*m*log(zzrth[1])/log(kappa));
        for(jjj=0,zrepr-1, equc[jj+jjj][M+2+m]-=a);
      );
    ););
    jj+=zrepr;
  );
  jj-1;
}


zset(v) =
{
  local(N,M,z,m,n,d,k);

  N=length(v);
  M=sum(n=1,N,v[n][1]);
  z=vector(M);
  m=1;
  for(n=1,N,
    d=(v[n][2][2]-v[n][2][1])/(v[n][1]-1);
    for(k=1,v[n][1], z[m]=v[n][2][1] + (k-1)*d + v[n][3]*I; m++;);
  );
  return(z);
}



/*
 Initialize the global system "equc" to be the equations for the
 first M Fourier coefficients in the relations
   f(z[j])=f(pullback(z[j])),   where j runs from 1 to length(z).
*/
initzequations(r,R,z,M,Ncs) =
{
  local (j,m,zz,s);

  equc = vector(length(z),x,vector(M));
  if (imag(R)!=0, s=0.5-imag(R);, s=0.5+I*R;);
  for(j=1,length(z),
    zz=pullback(z[j],r);
    for(m=1,M,
      if(m==Ncs,
        equc[j][m]=imag(zz)^(1-s) - imag(z[j])^(1-s);
      , if (m<Ncs,
        equc[j][m]=imag(zz)^s - imag(z[j])^s;
      ,
        equc[j][m]=sqrt(imag(zz))*real(besselk(I*R,2*Pi*(m-Ncs)*imag(zz)))*2*cos(2*Pi*(m-Ncs)*real(zz)) - sqrt(imag(z[j]))*real(besselk(I*R,2*Pi*(m-Ncs)*imag(z[j])))*2*cos(2*Pi*(m-Ncs)*real(z[j]));
      ););
    );
  );
}


/* Returns a vector  ecoeff  containing the coefficients of the
   Eisenstein series for PSL(2,Z).
   We use the notation:
     E(z,s)= ecoeff[1]*y^s + ecoeff[2]*y^(1-s) +
               + sum_[n=1...N] ecoeff[n+2]*sqrt(y)*kbes*2*cos(2*Pi*n*x).

   For the formulas, cf eg Hejhal, SLN 1001, p.76.
*/
ecoeffdirect(s,N)=
{
  local(ecoeff,c,n);

  ecoeff=vector(N);
  ecoeff[1]=1;
  ecoeff[2]=sqrt(Pi)*gamma(s-0.5)*zeta(2*s-1)/(gamma(s)*zeta(2*s));
  c=2*Pi^s/(gamma(s)*zeta(2*s));
  for(n=3,N, ecoeff[n]=c*(n-2)^(s-0.5)*sumdiv(n-2,X,X^(1-2*s)); );
  return(ecoeff);
}




/**********************************************************************
   Examples

(Note: Examples with numbers 1-4 are from my "old" program, using only
ONE Fourier expansions. Examples with numbers >=5 use TWO Fourier
expansions.)
**********************************************************************/

/* Examples using "Hejhal's algorithm".
 *******************************************/

/*
 r=1.0 gives GAMMA_r=PSL(2,Z). Bottom height of the fundamental
 domain = sqrt(3)/2=0.866025...

 The following case may be compared against
   http://www.math.uu.se/research/archive/astrombe/emaass/psl2z/coeff13
*/
exampleH1() =
{
  hejhalmethod(1.0,13.77975135189073894424367328151,12,13,0.85);
/* Here M=12 was found using  findgoodcutoffM(13.7797,0.85-0.03,1E-15). */
}

/* Note that there is no problem using LARGER M: */
exampleH1a() =
{
  hejhalmethod(1.0,13.77975135189073894424367328151,25,26,0.85);
}

/* A fail (R not very close to an eigenvalue). */
exampleH1b() =
{
  hejhalmethod(1.0,13.0,12,13,0.85);
}


/*
 The following is the smallest (non-zero) even eigenvalue on the
 arithmetic group GAMMA_r with r=1/(2*cos(Pi/4)); compare p.25 in
 Hejhal, "Eigenvals of the Lapl for Hecke tri grps", Mem of AMS 97 (1992).
 Bottom height of the fundamental domain = (1/2)*tan(Pi/4)=1/2.

 Note: The fact that the first Fourier coefficients don't seem to
 be accurate to more than ~ 1E-6 or so is of course due to the fact
 that the eigenvalue  "R=8.922877"  from Hejhal's book is only given
 to 6 decimal places. Using today's computer speed we could very quickly
 zoom in and get a more precise R-value!
*/
exampleH2()=
{
  hejhalmethod(1/(2*cos(Pi/4)),8.922877,19,22,0.49);
/* Here M=19 was found using  findgoodcutoffM(8.92,0.49-0.03,1E-15). */
}

/* A fail (R not very close to an eigenvalue).  */
exampleH3()=
{
  hejhalmethod(1/(2*cos(Pi/4)),8.0,19,22,0.49);
}

/*
 The following is the smallest (non-zero) even eigenvalue on the
 arithmetic group GAMMA_r with r=1/(2*cos(Pi/6)); compare p.25 in
 Hejhal, "Eigenvals of the Lapl for Hecke tri grps", Mem of AMS 97 (1992).
 Bottom height of the fundamental domain = (1/2)*tan(Pi/6)=0.28867513...
*/
exampleH4()=
{
  hejhalmethod(1/(2*cos(Pi/6)),5.098742,31,32,0.27);
/* Here M=31 was found using  findgoodcutoffM(5.1,0.27-0.03,1E-15). */
}



/* Examples using the more direct/general linear system.
 *****************************************************************/


/*
 The first bunch of examples are again for r=1.0 (viz GAMMA=PSL(2,Z))
 and R=13.77975135189073894424367328151.
 (cf. http://www.math.uu.se/research/archive/astrombe/emaass/psl2z/coeff13 )
*/

/* The following is very similar to using Hejhal's algorithm. */
exampleL1a()=
{
  primitivelinalgmethod_horo(1.0,13.77975135189073894424367328151,0.85,12,0);
}

/* Here choose the 14 points to not all lie on the same horocycle. */
exampleL1b()=
{
  local(z1,z2);
  z1=zset([[7,[-0.5,0.0],0.85],[7,[-0.5,0.0],0.75]]);
  z2=zset([[7,[-0.5,0.0],0.8],[7,[-0.5,0.0],0.7]]);
  primitivelinalgmethod(1.0,13.77975135189073894424367328151,z1,z2,15,0);
/* Note  findgoodcutoffM(13.78,0.7,1E-15) returns M=15. */
}

/* Here using the "better" (?) leastsquaremethod, i.e. allowing
   many more points than M! (Below M=15 and we use 40 and 50 points, resp.)
*/
exampleL1c()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,13.77975135189073894424367328151,z1,z2,15,0);
}

/* Same leastsquaremethod call, but with R=13.0, giving FAIL.. */
exampleL1d()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,13.0,z1,z2,15,0);
}

/* Just checking that it is no real bad to solve for more coefficients. */
exampleL1e()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,13.77975135189073894424367328151,z1,z2,20,0);
}

/* The next bunch of examples compute the Eisenstein series on PSL(2,Z).
  These examples serve two purposes: To check that we have (hopefully!)
  implemented handling of constant terms y^s and y^(1-s) correctly,
  and to check that there are no problems arising when dealing with
  small eigenvalues, i.e. R purely imaginary between 0 and -0.5*I!
*/

/* Eisenstein series on PSL(2,Z) for R=13.0, viz s=0.5+13*I. */
exampleL2a()=
{
  primitivelinalgmethod_horo(1.0,13.0,0.85,12,2);
}

/* Eisenstein series on PSL(2,Z) for R=-I*0.25, viz s=0.75. */
exampleL2b()=
{
  primitivelinalgmethod_horo(1.0,-I*0.25,0.85,12,2);
}

/* Eisenstein series on PSL(2,Z) for R=-I*0.45, viz s=0.95. */
exampleL2c()=
{
  primitivelinalgmethod_horo(1.0,-I*0.45,0.85,12,2);
}

/* The next three examples are the same three cases with the Eisenstein
   series as above, but now using leastsquaremethod, with many more sample
   points than M. */
exampleL2d()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,13.0,z1,z2,15,2);
}

exampleL2e()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,-I*0.25,z1,z2,15,2);
}

exampleL2f()=
{
  local(z1,z2);
  z1=zset([[20,[-0.5,0.0],0.85],[20,[-0.5,0.0],0.75]]);
  z2=zset([[25,[-0.5,0.0],0.8],[25,[-0.5,0.0],0.7]]);
  leastsquaremethod(1.0,-I*0.45,z1,z2,15,2);
}


/*
 Next we turn to r=0.5, viz.\ GAMMA_r conjugate to the theta group
 (a subgroup of index 3 in PSL(2,Z)). This group has TWO cusps!
 As discussed in
 Hejhal, "Eigenvals of the Lapl for Hecke tri grps", Mem of AMS 97 (1992),
 (esp see conclusion on bottom p.12) we always like to choose points lying
 BELOW the fundamental domain; hence for the present case we would really
 like to chose points lying "infinitely far down" in the hyperbolic plane
 -- which is of course impossible.
 Actually the method which people use to handle this case is to
 solve simultaneously for the Fourier coefficients at BOTH cusps!
 But it seems to me that if there is a way to handle cases with r<1/2
 using only the Fourier expansion at the cusp at infinity, then such
 a method ought also to work in the case r=1/2 !?!?!?
*/

/* Note that R=13.77975135189073894424367328151  is an (even) eigenvalue
  on the theta group, since it is an even eigenvalue on PSL(2,Z).
*/

/* The following: FAILS! But strangely SOME coefficients come out correctly
   it seems, and agree with the cusp form on PSL(2,Z)\H. To understand better
   (if one is interested) one should of course start by computing the Fourier
   expansion of the sought-for eigenfunction on GAMMA_0.5;  it is a simple
   transform of the cusp form on
   http://www.math.uu.se/research/archive/astrombe/emaass/psl2z/coeff13
*/
exampleL3a()=
{
  local(z1,z2);
/* Note the following points all lie outside of the fundamental domain: */
  z1=zset([[15,[-0.29,0.0],0.4],[15,[-0.35,0.0],0.35]]);
  z2=zset([[15,[-0.33,0.0],0.37],[15,[-0.38,0.0],0.32]]);
  leastsquaremethod(0.5,13.77975135189073894424367328151,z1,z2,22,0);
/* Note  findgoodcutoffM(13.78,0.35,1E-10) returns M=22. */
}

/* Trying again, with more points and larger M!  */
exampleL3b()=
{
  local(z1,z2);
/* Note the following points all lie outside of the fundamental domain: */
  z1=zset([[15,[-0.29,0.0],0.4],[15,[-0.35,0.0],0.35],[15,[-0.39,0.0],0.3]]);
  z2=zset([[15,[-0.33,0.0],0.37],[15,[-0.38,0.0],0.32],[15,[-0.42,0.0],0.27]]);
  leastsquaremethod(0.5,13.77975135189073894424367328151,z1,z2,35,0);
/* Note  findgoodcutoffM(13.78,0.27,1E-15) returns M=35. */
}


/* Finally we turn to THE REAL TASK: To try to compute an eigenfunction
 in some case with r<1/2! Note McMullen has computed the Hausdorff
 dimension of the limit set in his paper "Hausdorff dimension ... III".
 I don't see any table (or graph) for this case in his paper; however
 installing his program "hdim" (see
    http://www.math.harvard.edu/~ctm/programs.html )
 and running  "bin/hdim -H 0.1 0.9 0.1"  gives the following output:

   Hecke Groups : Eps 1.00e-03

 Radius    Dimension   Cover  Matrix Steps
Iteration limit of 400 reached
 0.10000  0.49522707    1764    3528  400
 0.20000  0.55179779    1826    3652  364
 0.30000  0.59684045    1916    3832  301
 0.40000  0.63815881    2052    4104  225
Iteration limit of 400 reached
 0.50000  0.67881115    2254    4508  400
Iteration limit of 400 reached
 0.60000  0.72073500    2550    5100  400
Iteration limit of 400 reached
 0.70000  0.76574757    2988    5976  400
Iteration limit of 400 reached
 0.80000  0.81638930    3642    7284  400
 0.90000  0.87810176    4846    9692  381

One guesses that the cases where "iteration limit reached" are LESS
trustworthy than the other cases. For now, let us consider the case
"radius 0.9, dim=0.87810176" in the above table.
Note that our r is HALF of McMullen's r, i.e. we should take r=0.45,
and then McMullen's output implies that the lowest eigenvalue of
the Laplacian should be  lambda=s(1-s), with s=0.87810176,
thus R=-I*(0.87810176-0.5).
*/

/* Note we are seeking a general L2-function, hence we should call
 leastsquaremethod  with Ncs=1!
*/

/* The following FAILS! */
exampleL4a()=
{
  local(z1,z2);
/* Note the following points all lie outside of the fundamental domain: */
  z1=zset([[15,[-0.28,0.0],0.35],[15,[-0.33,0.0],0.3]]);
  z2=zset([[15,[-0.3,0.0],0.33],[15,[-0.32,0.0],0.31]]);
  leastsquaremethod(0.45,-I*(0.87810176-0.5),z1,z2,21,1);
/* Note  findgoodcutoffM(-I*0.37,0.3,1E-15) returns M=21. */
}

/* For fun: Can we see if "false R" gives "even worse output"!?!
   (Answer: NO, it's just as bad, not worse.)    */
exampleL4b()=
{
  local(z1,z2);
/* Note the following points all lie outside of the fundamental domain: */
  z1=zset([[15,[-0.28,0.0],0.35],[15,[-0.33,0.0],0.3]]);
  z2=zset([[15,[-0.3,0.0],0.33],[15,[-0.32,0.0],0.31]]);
  leastsquaremethod(0.45,-I*0.4,z1,z2,21,1);
}

/* First tries with TWO expansions. */

exampleL5a()=
{
  local(r,h0,y0,R,M,MM);

  r=0.35;
  h0=0.1;
/* Note infheight(r,h0)=0.2024... */
  y0=0.2;
  R=-I*(0.76574757-0.5);
/* findgoodcutoffM(-I*(0.76574757-0.5),0.2-0.04,1e-10) gives 28. */
  M=28;
  MM=20;   /* This is just a guess!!! */
  leastsquaremethod2expansions(r,R,y0,M,h0,MM);
}

exampleL5b()=
{
  local(r,h0,y0,R,M,MM);

  r=0.35;
  alpha=2.2;
/* Note infheight2(r,alpha)=0.343... */
/* Note also h0>=-r, so that infheight(r,h0) gives right answer.. */
  y0=0.34;
  R=-I*(0.76574757-0.5);
/* findgoodcutoffM(-I*(0.76574757-0.5),0.34-0.04,1e-10) gives 15. */
  M=15;
  MM=4;   /* This is just a guess!!! */
  leastsquaremethod2expansions(r,R,y0,M,alpha,MM);
}

exampleL5c()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  r=0.35;
  alpha=2.2;
/* Note infheight2(r,alpha)=0.343... */
/* Note also h0>=-r, so that infheight(r,h0) gives right answer.. */
  y0=0.34;
  M=15;
  MM=8;   /* This is just a guess!!! */
  R1=-I*(0.7670524170090910430752-0.5);
  c1=precision(leastsquaremethod2expansions(r,R1,y0,M,alpha,MM)[1],30);
  R2=-I*(0.7670524170090910430753-0.5);
  c2=precision(leastsquaremethod2expansions(r,R2,y0,M,alpha,MM)[1],30);
  print(R1"  gives  "c1);
  print(R2"  gives  "c2);
  R=(c1*R2-c2*R1)/(c1-c2);
  print("pred: "R);
}

exampleL5d()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  r=0.35;
  alpha=2.0;
/* Note infheight2(r,alpha)=0.32069... */
/* Note also h0>=-r, so that infheight(r,h0) gives right answer.. */
  y0=0.32;
  M=20;
  MM=8;   /* This is just a guess!!! */
  R1=-I*(0.7670524170091020-0.5);
  c1=precision(leastsquaremethod2expansions(r,R1,y0,M,alpha,MM)[1],30);
  R2=-I*(0.76705241700910207-0.5);
  c2=precision(leastsquaremethod2expansions(r,R2,y0,M,alpha,MM)[1],30);
  print(R1"  gives  "c1);
  print(R2"  gives  "c2);
  R=(c1*R2-c2*R1)/(c1-c2);
  print("pred: "R);
}

exampleL5e()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,40);
  r=0.35; alpha=2.2; y0=0.34; M=15; MM=12;
  r=0.35; alpha=2.0; y0=0.32; M=20; MM=8;
  r=0.35; alpha=2.0; y0=0.32; M=16; MM=8;
  r=0.35; alpha=2.2; y0=0.34; M=20; MM=12;
/*  zoomin(r,alpha,y0,M,MM,0.767052,0.000001); */
/*  zoomin(r,alpha,y0,M,MM,0.76,1e-2);   */
  zoomin(r,alpha,y0,M,MM,0.7670524170,2e-11);
}

exampleL5f()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,40);
  r=0.35; alpha=2.2; y0=0.34; M=26; MM=16;
  zoomin(r,alpha,y0,M,MM,0.7670524170091020567,3e-19);
}

exampleL5f2()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,60);
  r=0.35; alpha=2.2; y0=0.34; M=40; MM=25;
  zoomin(r,alpha,y0,M,MM,0.767052417009102056771501,2e-24);
}

/* The following results in:   The eigenvalue clearly seems to lie in the
   interval between s=0.767052417009102056771502088642595062766687 and
   s + 2e-43.
   (But looking at the Fourier coefficients we see that something seems
    to be causing small errors in the 45+ decimals... Perhaps it is some
    loss of accuracy in the Legendre function?)
*/
exampleL5f3()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,60);
  r=0.35; alpha=2.2; y0=0.34; M=60; MM=35;
  zoomin(r,alpha,y0,M,MM,0.7670524170091020567715020886425950625,4e-37);
}

/* As an extra check: Try the same thing as above but with different
   alpha and y0.
*/
exampleL5g()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,40);
  r=0.35; alpha=2.0; y0=0.32; M=26; MM=16;
  zoomin(r,alpha,y0,M,MM,0.7670524170091020567,3e-19);
}

exampleL5g2()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,40);
  r=0.35; alpha=2.0; y0=0.32; M=35; MM=25;
  zoomin(r,alpha,y0,M,MM,0.76705241700910205677147,3e-23);
}

exampleL5g3()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,48);
  r=0.35; alpha=2.0; y0=0.32; M=45; MM=25;
  zoomin(r,alpha,y0,M,MM,0.767052417009102056771502088642,2e-30);
}

/* Here keeping M,MM and just raising precision... */
exampleL5g4()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,60);
  r=0.35; alpha=2.0; y0=0.32; M=45; MM=25;
  zoomin(r,alpha,y0,M,MM,0.767052417009102056771502088642594,2e-33);
}

/* The following results in:   The eigenvalue seems to lie in the
   interval between s=0.767052417009102056771502088642595062766686 and
   s + 1e-42.
*/
exampleL5g5()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,60);
  r=0.35; alpha=2.0; y0=0.32; M=50; MM=30;
  zoomin(r,alpha,y0,M,MM,0.767052417009102056771502088642595062767,3e-39);
}



/* Examples using explicit values from McMullen's program hdim (modified). */
example6a() =
{
  local(delta,Y,Q,Fvals,a1,a2,a3,m,R);
/* Values along horocycles obtained by hdim -n 400 -e 0.001 -h 0.7 */

  delta=0.76574759;
  R=-I*(0.76574757-0.5);
  print("R="R);
  Q=40; Y=1.0;
  Fvals=[1.02929668,1.02930476,1.02932090,1.02934500,1.02937690,1.02941642,1.02946331,1.02951728,1.02957801,1.02964513,1.02971823,1.02979685,1.02988052,1.02996873,1.03006093,1.03015656,1.03025504,1.03035575,1.03045808,1.03056140,1.03066507,1.03076845,1.03087091,1.03097181,1.03107053,1.03116646,1.03125900,1.03134757,1.03143164,1.03151068,1.03158419,1.03165173,1.03171286,1.03176722,1.03181445,1.03185427,1.03188643,1.03191072,1.03192700,1.03193517,1.03193517,1.03192700,1.03191072,1.03188643,1.03185427,1.03181445,1.03176722,1.03171286,1.03165173,1.03158419,1.03151068,1.03143164,1.03134757,1.03125900,1.03116646,1.03107053,1.03097181,1.03087091,1.03076845,1.03066507,1.03056140,1.03045808,1.03035575,1.03025504,1.03015656,1.03006093,1.02996873,1.02988052,1.02979685,1.02971823,1.02964513,1.02957801,1.02951728,1.02946331,1.02941642,1.02937690,1.02934500,1.02932090,1.02930476,1.02929668];
  a1=computefouriercoeffs(10,Q,Y,Fvals,R);
  Q=43; Y=0.9;
  Fvals=[1.00337385,1.00338691,1.00341299,1.00345194,1.00350357,1.00356761,1.00364371,1.00373148,1.00383047,1.00394015,1.00405995,1.00418924,1.00432734,1.00447352,1.00462703,1.00478703,1.00495270,1.00512315,1.00529748,1.00547477,1.00565407,1.00583444,1.00601490,1.00619449,1.00637226,1.00654726,1.00671853,1.00688517,1.00704627,1.00720097,1.00734844,1.00748787,1.00761851,1.00773965,1.00785064,1.00795088,1.00803981,1.00811696,1.00818190,1.00823428,1.00827382,1.00830030,1.00831358,1.00831358,1.00830030,1.00827382,1.00823428,1.00818190,1.00811696,1.00803981,1.00795088,1.00785064,1.00773965,1.00761851,1.00748787,1.00734844,1.00720097,1.00704627,1.00688517,1.00671853,1.00654726,1.00637226,1.00619449,1.00601490,1.00583444,1.00565407,1.00547477,1.00529748,1.00512315,1.00495270,1.00478703,1.00462703,1.00447352,1.00432734,1.00418924,1.00405995,1.00394015,1.00383047,1.00373148,1.00364371,1.00356761,1.00350357,1.00345194,1.00341299,1.00338691,1.00337385];
  a2=computefouriercoeffs(10,Q,Y,Fvals,R);
  Q=46; Y=0.8;
  Fvals=[0.97421853,0.97423977,0.97428217,0.97434553,0.97442958,0.97453395,0.97465815,0.97480164,0.97496378,0.97514382,0.97534097,0.97555433,0.97578293,0.97602575,0.97628168,0.97654956,0.97682816,0.97711621,0.97741239,0.97771535,0.97802367,0.97833594,0.97865071,0.97896652,0.97928189,0.97959535,0.97990543,0.98021067,0.98050964,0.98080092,0.98108313,0.98135492,0.98161502,0.98186216,0.98209517,0.98231294,0.98251441,0.98269862,0.98286468,0.98301178,0.98313922,0.98324638,0.98333274,0.98339787,0.98344147,0.98346333,0.98346333,0.98344147,0.98339787,0.98333274,0.98324638,0.98313922,0.98301178,0.98286468,0.98269862,0.98251441,0.98231294,0.98209517,0.98186216,0.98161502,0.98135492,0.98108313,0.98080092,0.98050964,0.98021067,0.97990543,0.97959535,0.97928189,0.97896652,0.97865071,0.97833594,0.97802367,0.97771535,0.97741239,0.97711621,0.97682816,0.97654956,0.97628168,0.97602575,0.97578293,0.97555433,0.97534097,0.97514382,0.97496378,0.97480164,0.97465815,0.97453395,0.97442958,0.97434553,0.97428217,0.97423977,0.97421853];
  a3=computefouriercoeffs(10,Q,Y,Fvals,R);
/* Just "for fun": */
  print("DIVIDING THROUGH WITH a[1]=",a1[1]);
  a2=(1/a1[1])*a2;
  a3=(1/a1[1])*a3;
  a1=(1/a1[1])*a1;
  for(m=1,11, print(m-1" "a1[m]" "a2[m]" "a3[m]));
}

/* Examples using explicit values from McMullen's program hdim (modified). */
example6b() =
{
  local(delta,Y,Q,Fvals,a1,a2,a3,m,R);
/* Values along horocycles obtained by hdim -n 400 -e 0.001 -h 0.7 */

  delta=0.76574759;
  R=-I*(0.76574757-0.5);
  print("R="R);
  Q=50; Y=0.4;
  Fvals=[0.77967887,0.77986480,0.78023629,0.78079263,0.78153276,0.78245523,0.78355824,0.78483956,0.78629657,0.78792619,0.78972490,0.79168867,0.79381300,0.79609281,0.79852250,0.80109584,0.80380602,0.80664558,0.80960639,0.81267967,0.81585592,0.81912498,0.82247597,0.82589733,0.82937680,0.83290148,0.83645785,0.84003179,0.84360864,0.84717328,0.85071016,0.85420341,0.85763694,0.86099449,0.86425976,0.86741656,0.87044885,0.87334092,0.87607750,0.87864388,0.88102603,0.88321075,0.88518574,0.88693978,0.88846276,0.88974585,0.89078154,0.89156373,0.89208779,0.89235060,0.89235060,0.89208779,0.89156373,0.89078154,0.88974585,0.88846276,0.88693978,0.88518574,0.88321075,0.88102603,0.87864388,0.87607750,0.87334092,0.87044885,0.86741656,0.86425976,0.86099449,0.85763694,0.85420341,0.85071016,0.84717328,0.84360864,0.84003179,0.83645785,0.83290148,0.82937680,0.82589733,0.82247597,0.81912498,0.81585592,0.81267967,0.80960639,0.80664558,0.80380602,0.80109584,0.79852250,0.79609281,0.79381300,0.79168867,0.78972490,0.78792619,0.78629657,0.78483956,0.78355824,0.78245523,0.78153276,0.78079263,0.78023629,0.77986480,0.77967887];
  a1=computefouriercoeffs(10,Q,Y,Fvals,R);
  Q=53; Y=0.35;
  Fvals=[0.73575933,0.73597016,0.73639156,0.73702312,0.73786417,0.73891382,0.74017095,0.74163411,0.74330161,0.74517140,0.74724108,0.74950784,0.75196846,0.75461923,0.75745593,0.76047376,0.76366734,0.76703059,0.77055676,0.77423832,0.77806698,0.78203359,0.78612814,0.79033973,0.79465653,0.79906579,0.80355382,0.80810602,0.81270686,0.81733996,0.82198813,0.82663338,0.83125707,0.83583995,0.84036228,0.84480393,0.84914455,0.85336365,0.85744079,0.86135571,0.86508849,0.86861975,0.87193076,0.87500364,0.87782153,0.88036871,0.88263079,0.88459481,0.88624943,0.88758500,0.88859365,0.88926944,0.88960834,0.88960834,0.88926944,0.88859365,0.88758500,0.88624943,0.88459481,0.88263079,0.88036871,0.87782153,0.87500364,0.87193076,0.86861975,0.86508849,0.86135571,0.85744079,0.85336365,0.84914455,0.84480393,0.84036228,0.83583995,0.83125707,0.82663338,0.82198813,0.81733996,0.81270686,0.80810602,0.80355382,0.79906579,0.79465653,0.79033973,0.78612814,0.78203359,0.77806698,0.77423832,0.77055676,0.76703059,0.76366734,0.76047376,0.75745593,0.75461923,0.75196846,0.74950784,0.74724108,0.74517140,0.74330161,0.74163411,0.74017095,0.73891382,0.73786417,0.73702312,0.73639156,0.73597016,0.73575933];
  a2=computefouriercoeffs(10,Q,Y,Fvals,R);
  Q=56; Y=0.3;
  Fvals=[0.68319550,0.68342933,0.68389690,0.68459819,0.68553309,0.68670149,0.68810317,0.68973787,0.69160516,0.69370449,0.69603512,0.69859605,0.70138603,0.70440347,0.70764635,0.71111224,0.71479816,0.71870052,0.72281509,0.72713685,0.73165997,0.73637770,0.74128228,0.74636491,0.75161562,0.75702323,0.76257531,0.76825809,0.77405649,0.77995402,0.78593287,0.79197386,0.79805650,0.80415909,0.81025875,0.81633155,0.82235263,0.82829636,0.83413649,0.83984633,0.84539893,0.85076733,0.85592469,0.86084459,0.86550121,0.86986956,0.87392571,0.87764700,0.88101229,0.88400213,0.88659901,0.88878752,0.89055452,0.89188931,0.89278375,0.89323235,0.89323235,0.89278375,0.89188931,0.89055452,0.88878752,0.88659901,0.88400213,0.88101229,0.87764700,0.87392571,0.86986956,0.86550121,0.86084459,0.85592469,0.85076733,0.84539893,0.83984633,0.83413649,0.82829636,0.82235263,0.81633155,0.81025875,0.80415909,0.79805650,0.79197386,0.78593287,0.77995402,0.77405649,0.76825809,0.76257531,0.75702323,0.75161562,0.74636491,0.74128228,0.73637770,0.73165997,0.72713685,0.72281509,0.71870052,0.71479816,0.71111224,0.70764635,0.70440347,0.70138603,0.69859605,0.69603512,0.69370449,0.69160516,0.68973787,0.68810317,0.68670149,0.68553309,0.68459819,0.68389690,0.68342933,0.68319550];
  a3=computefouriercoeffs(10,Q,Y,Fvals,R);
  print("DIVIDING THROUGH WITH a[1]=",a1[1]);
  a2=(1/a1[1])*a2;
  a3=(1/a1[1])*a3;
  a1=(1/a1[1])*a1;
  for(m=1,11, print(m-1" "a1[m]" "a2[m]" "a3[m]));
}

/* Compute "hyp" Fourier coefficients. */
example6c() =
{
  local(delta,th,Q,Fvals,a1,a2,a3,m,R,ccc);
/* Values along hypercycle obtained by hdim -n 400 -e 0.001 -h 0.7 */

  delta=0.76574759;
  R=-I*(0.76574757-0.5);
  print("R="R);
  Q=50; th=1.5;
  Fvals=[0.71332819,0.71334882,0.71341039,0.71351195,0.71365189,0.71382803,0.71403758,0.71427725,0.71454327,0.71483146,0.71513729,0.71545592,0.71578235,0.71611143,0.71643796,0.71675681,0.71706292,0.71735147,0.71761790,0.71785799,0.71806796,0.71824446,0.71838471,0.71848650,0.71854819,0.71856883,0.71854807,0.71848625,0.71838435,0.71824397,0.71806735,0.71785726,0.71761704,0.71735048,0.71706179,0.71675553,0.71643655,0.71610986,0.71578063,0.71545404,0.71513524,0.71482924,0.71454087,0.71427465,0.71403478,0.71382503,0.71364868,0.71350850,0.71340670,0.71334488];
  a1=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
  Q=53; th=1.7;
  Fvals=[0.77428593,0.77432273,0.77443264,0.77461411,0.77486462,0.77518067,0.77555786,0.77599092,0.77647380,0.77699976,0.77756145,0.77815102,0.77876020,0.77938046,0.78000311,0.78061940,0.78122068,0.78179850,0.78234470,0.78285160,0.78331205,0.78371955,0.78406833,0.78435346,0.78457092,0.78471761,0.78479146,0.78479143,0.78471751,0.78457075,0.78435324,0.78406803,0.78371919,0.78331162,0.78285110,0.78234413,0.78179784,0.78121995,0.78061859,0.78000221,0.77937947,0.77875912,0.77814984,0.77756017,0.77699837,0.77647229,0.77598929,0.77555610,0.77517878,0.77486258,0.77461192,0.77443029,0.77432021];
  a2=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
  Q=56; th=1.9;
  Fvals=[0.82686948,0.82693548,0.82713266,0.82745855,0.82790912,0.82847875,0.82916037,0.82994551,0.83082438,0.83178606,0.83281854,0.83390896,0.83504370,0.83620856,0.83738896,0.83857008,0.83973709,0.84087528,0.84197030,0.84300830,0.84397611,0.84486146,0.84565307,0.84634084,0.84691599,0.84737116,0.84770052,0.84789984,0.84796656,0.84789983,0.84770051,0.84737114,0.84691597,0.84634081,0.84565303,0.84486141,0.84397606,0.84300823,0.84197023,0.84087520,0.83973699,0.83856996,0.83738882,0.83620841,0.83504352,0.83390876,0.83281831,0.83178579,0.83082408,0.82994516,0.82915998,0.82847831,0.82790862,0.82745799,0.82713203,0.82693477];
  a3=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
/* Just "for fun": */
  ccc=1.033151741564709576200942471;
  print("DIVIDING THROUGH WITH ccc=",ccc);
  a2=(1/ccc)*a2;
  a3=(1/ccc)*a3;
  a1=(1/ccc)*a1;

  for(m=1,11, print(m-1" "a1[m]" "a2[m]" "a3[m]));
}

/* Compute "hyp" Fourier coefficients. */
example6d() =
{
  local(delta,th,Q,Fvals,a1,a2,a3,m,R,ccc);
/* Values along hypercycle obtained by hdim -n 400 -e 0.001 -h 0.7 */

  delta=0.76574759;
  R=-I*(0.76574757-0.5);
  print("R="R);
  Q=50; th=1.9;
  Fvals=[0.82686948,0.82695225,0.82719926,0.82760666,0.82816808,0.82887480,0.82971578,0.83067790,0.83174615,0.83290382,0.83413281,0.83541387,0.83672689,0.83805125,0.83936608,0.84065065,0.84188462,0.84304844,0.84412362,0.84509302,0.84594116,0.84665447,0.84722152,0.84763320,0.84788289,0.84796656,0.84788288,0.84763319,0.84722150,0.84665445,0.84594112,0.84509297,0.84412356,0.84304838,0.84188454,0.84065056,0.83936598,0.83805112,0.83672675,0.83541370,0.83413261,0.83290359,0.83174588,0.83067759,0.82971542,0.82887439,0.82816761,0.82760612,0.82719865,0.82695155];
  a1=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
  Q=53; th=2.1;
  Fvals=[0.86739148,0.86753865,0.86797808,0.86870369,0.86970548,0.87096962,0.87247868,0.87421185,0.87614521,0.87825211,0.88050345,0.88286812,0.88531340,0.88780535,0.89030930,0.89279029,0.89521352,0.89754484,0.89975122,0.90180122,0.90366546,0.90531704,0.90673203,0.90788979,0.90877336,0.90936976,0.90967019,0.90967022,0.90936985,0.90877350,0.90788999,0.90673229,0.90531736,0.90366583,0.90180166,0.89975171,0.89754539,0.89521413,0.89279096,0.89031004,0.88780615,0.88531426,0.88286904,0.88050443,0.87825315,0.87614631,0.87421300,0.87247989,0.87097088,0.86970679,0.86870504,0.86797947,0.86754007];
  a2=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
  Q=56; th=2.3;
  Fvals=[0.88871620,0.88897895,0.88976383,0.89106105,0.89285441,0.89512163,0.89783457,0.90095970,0.90445855,0.90828819,0.91240181,0.91674927,0.92127770,0.92593203,0.93065560,0.93539066,0.94007899,0.94466241,0.94908341,0.95328576,0.95721517,0.96082004,0.96405221,0.96686775,0.96922778,0.97109922,0.97245552,0.97327723,0.97355249,0.97327733,0.97245573,0.97109955,0.96922822,0.96686830,0.96405287,0.96082082,0.95721607,0.95328678,0.94908456,0.94466369,0.94008040,0.93539221,0.93065729,0.92593387,0.92127968,0.91675140,0.91240409,0.90829063,0.90446116,0.90096247,0.89783750,0.89512473,0.89285768,0.89106449,0.88976745,0.88898274];
  a3=computehypfouriercoeffs(10,Q,th,Fvals,R,0.35,1);
/* Just "for fun": */
  ccc=1.033151741564709576200942471;
  print("DIVIDING THROUGH WITH ccc=",ccc);
  a2=(1/ccc)*a2;
  a3=(1/ccc)*a3;
  a1=(1/ccc)*a1;
  for(m=1,11, print(m-1" "a1[m]" "a2[m]" "a3[m]));
}

/*---------------------------------------
  -Below is code added by Alex Karlovitz-
  ---------------------------------------*/

/* Same as zoomin above but without printing anything */
zoom_in_no_print(r,alpha,y0,M,MM,s,sdelta)=
{
  local(snew,R1,R2,c1,c2,j,smax,smin,smid,sdeltanew);

  snew=vector(4);
  while(1,
    R1=-I*(s-0.5);
    R2=-I*(s+sdelta-0.5);
    c1=leastsquaremethod2expansions_no_print(r,R1,y0,M,alpha,MM);
    c2=leastsquaremethod2expansions_no_print(r,R2,y0,M,alpha,MM);
    /*c1=precision(c1,default(realprecision));
    c2=precision(c2,default(realprecision));*/
    smax=0.0; smin=100.0;
    for(j=1,4,
      snew[j]=(c1[j]*(s+sdelta)-c2[j]*s)/(c1[j]-c2[j]);
      smax=max(smax,snew[j]);
      smin=min(smin,snew[j]);
    );
    smid=0.5*(smax+smin);
/* Worth continuing? */
    sdeltanew=(smax-smin)*5;
    if(sdeltanew>0.5*sdelta,
      return(smid);
    );
    sdelta=sdeltanew;
    s=smid-0.5*sdelta;
  );
}

/* Same as leastsquaremethod2expansions above but without printing anything */
leastsquaremethod2expansions_no_print(r,R,y0,M,alpha,MM) =
{
  local(zs,j,kappa,k,A,AA,x1,x2,Ne,jj);

  kappa=((1+sqrt(1-4*r^2))/(2*r))^2;
  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+y0*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha,exp(j/(2*(MM+MM))*log(kappa))));
  Ne=initzequations2expansions(r,R,y0-0.01,zs,M,alpha+0.1,MM);
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  x1=solveequsyst(M+MM+1,M+MM+2,1);

  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+(y0-0.02)*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha+0.05,exp(j/(2*(MM+MM))*log(kappa))));
  Ne=initzequations2expansions(r,R,y0-0.03,zs,M,alpha+0.1,MM);
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  x2=solveequsyst(M+MM+1,M+MM+2,1);

  return([x1[2]-x2[2],x1[3]-x2[3],x1[M+2]-x2[M+2],x1[M+3]-x2[M+3]]);
}

/*  Just changing Strombergsson's method to return error between two sets of
    Fourier coefficients
      r - Hecke group parameter (group generated by z+1 and -r^2/z)
      R = -I*(s - 0.5)
      y0 - height below which we don't allow cuspidal expansion
      M - number of points in cuspidal expansion
      alpha - angle above which we don't allow flare expansion
      MM - number of points in flare expansion */
least_square_method_2expns(r,R,y0,M,alpha,MM) =
{
  local(zs,j,kappa,k,A,AA,x1,x2,Ne,jj);

  kappa=((1+sqrt(1-4*r^2))/(2*r))^2;
  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+y0*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha,exp(j/(2*(MM+MM))*log(kappa))));
  Ne=initzequations2expansions(r,R,y0-0.01,zs,M,alpha+0.1,MM);
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  x1=solveequsyst(M+MM+1,M+MM+2,1);

  zs=vector(M+2+MM+MM);
  for(j=1,M+2, zs[j]=(j-1)/(2*(M+2))+(y0-0.02)*I);
  for(j=1,MM+MM, zs[M+2+j]=hyptotrue(r,alpha+0.05,exp(j/(2*(MM+MM))*log(kappa))));
  Ne=initzequations2expansions(r,R,y0-0.03,zs,M,alpha+0.1,MM);
  A=matrix(Ne,M+MM+2,k,j,equc[k][j]);
  AA=mattranspose(A)*A;
  equc=vector(M+MM+1,k,vector(M+MM+2,j,AA[k+1,j]));
  x2=solveequsyst(M+MM+1,M+MM+2,1);

  return(norml2(x1 - x2));
}

/*  Use Hejhal's original zoom in method: search for s in a grid of
    points, then look at continually finer grids at best test points.
    Get best based on minimum error in Fourier coefficients between two
    sets of test points.*/
grid_zoom_in(r,alpha,y0,M,MM,s_start,grid_size_start, num_steps)=
{
  local(best_s, grid_size, s_list, error_list, R, idx);

  best_s = s_start;
  grid_size = grid_size_start;

  /* repeat process for num_steps */
  for(i = 1, num_steps,
    /* print best s so far */
    print("Current guess: s = "best_s);

    /* get list of guesses */
    s_list = vector(11, n, best_s - 5*grid_size + (n-1)*grid_size);
    error_list = vector(11, n, 0);

    /* loop through grid of s values */
    for(j = 1, 11,
      R = -I*(s_list[j] - 0.5);
      error_list[j] = least_square_method_2expns(r,R,y0,M,alpha,MM);
    );

    /* print list of s values and corresponding errors */
    /*print("s guesses: "s_list);
    print("errors: "error_list);*/

    /* get s with minimum error to search near */
    vecmin(error_list, &idx);
    best_s = s_list[idx];

    /* update grid size */
    grid_size = grid_size*0.1;
  );

  return(best_s);
}

/* Run one iteration of the secant method zoom in */
exampleK1() =
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,32);
  r=0.35; alpha=2.0; y0=0.32; M=15; MM=5;
  zoomin(r,alpha,y0,M,MM,0.76,.005);
}

/* Set up to run grid zoom in algorithm */
exampleKgrid() =
{
  local(r, alpha, y0, M, MM, s_start, grid_size_start, num_steps);

  r = 0.35;
  alpha = 2.0;
  y0 = 0.32;
  M = 15;
  MM = 5;
  s_start = 0.76;
  grid_size_start = 0.01;
  num_steps = 2;

  print(grid_zoom_in(r,alpha,y0,M,MM,s_start,grid_size_start, num_steps));
  /* real answer to 22 decimal places is
     0.7670524170090910430752 */
}

/* Run a bunch of secant methods with varying inputs, and save results */
secant_methods() =
{
  local(r, alpha, y0, Ms, M, MMs, MM, R, delta, precs, s, s_true);
  s_true = 0.76705241700910205677150208864259506276668;

  /* Set static values for rest of computations */
  r=0.35; alpha=2.0; y0=0.32; R = 0.76; delta = 0.01;

  /* Modify lists here; all combinations of values
     taken from these lists will be performed. */
  Ms = [100];
  MMs = [50];
  precs = [256];

  /* nested loop through M, MM, and prec values */
  for(i=1, length(Ms),
    M = Ms[i];
    for(j=1, length(MMs),
      MM = MMs[j];
      for(k=1, length(precs),
        default(realprecision, precs[k]);
        s = zoom_in_no_print(r,alpha,y0,M,MM,R,delta);
        print("M = "M);
        print("MM = "MM);
        print("prec = "precs[k]);
        print("Error = "abs(s - s_true));
        print(" ");
      );
    );
  );
}

/*
  The highest precision example Strombergsson ran was in exampleL5f3.
  Let's see what happens if we increase the precision.
*/
example_high_prec()=
{
  local(r,h0,y0,R1,R2,R,M,MM,c1,c2);

  default(realprecision,100);
  r=0.35; alpha=2.2; y0=0.34; M=100; MM=65;
  zoomin(r,alpha,y0,M,MM,0.76705241700910205677150208864259506276668707761814270169822396,4e-62);
}
