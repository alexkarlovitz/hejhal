/*
This file contains PARI code to run Hejhal's algorithm on a
Schottky group with respect to the flare expansion.
That is, we split a fundamental domain into pieces in which
a certain Fourier expansion is "best."
A lot of the code is borrowed from Andreas Strombergsson.
*/

/*
We assume the Schottky group is generated by 3 circles of equal
size in the disk model, symmetrically spaced around the unit circle.
*/

/* Author: Alex Karlovitz */

/**********************************************************************
  Special functions (from Strombergsson)
**********************************************************************/

/* See def in GR, 9.100. We sum up to and including the z^N-term.
 Chooses N by the following (completely ad hoc and sloppy heuristic)
 method: Stop when p has decreased >= 10 times in a row and |p|<re*|s|. */

hypergeom(a,b,c,z)=
{
  local(s,p,pp,n,r,re,prec);

  /* re: Desired relative error bound for hypergeom function.
     Let's make it correspond to current precision. */
  prec = default(realprecision);
  re = 10^(-prec);

  s=1;
  p=1;
  r=0;
  n=0;
  while(1,
    pp=(a+n)*(b+n)/((c+n)*(1+n))*z;
    if (abs(pp)<1, r++, r=0);
    p=p*pp;
    s+=p;
    if ((r>=10 && abs(p)<re*abs(s)), return(s););
    n++;
  );
  s;
}

/* Legendre function of the first kind, for -1<=x<=1.  */
/* See def in GR, 8.704.  */
Plegendre(mu,nu,x)=
{
  real(1/gamma(1-mu)*((1+x)/(1-x))^(mu/2)*hypergeom(-nu,nu+1,1-mu,(1-x)/2));
}

/**********************************************************************
  Disk model functions
**********************************************************************/

/*
Map from upper half plane model to disk model.
*/
cayley_transform(z) =
{
  (z - I)/(z + I);
}

/* Map from disk model to upper half plane model */
inv_cayley_transform(w) =
{
  I*(1 + w)/(1 - w);
}

/**********************************************************************
  Whittaker functions
**********************************************************************/

/* Whittaker function in the flare expansion */
flare_Whitt(thet, m, s, kappa)=
{
  sqrt(sin(thet))*Plegendre(0.5-s, -0.5+2*Pi*m*I/log(kappa), cos(thet));
}

/**********************************************************************
  Schottky group functions
**********************************************************************/

/* Computes reflection through geodesic semicircle in upper half plane */
reflect(z, cent, rad)=
{
  return( rad^2 / (real(z) - I*imag(z) - cent) + cent );
}

/*
Given angle defining the symmetric Schottky group, gets the circle data
for the doubled group in the upper half plane model.

NOTE: each row of circles gives [center, radius] of a circle
*/
get_circle_data(thet)=
{
  local(circles_start, center_angle, ep1, ep2, refl_center, refl_rad,
    circles_doubled, ep1_new, ep2_new, circles_shifted, ep3, ep4);

  /* Start with circles before doubling */
  circles_start = vector(3, x, vector(2));
  for(i = 0, 2,
    center_angle = i*2*Pi/3;
    ep1 = inv_cayley_transform(exp(I*(center_angle - thet/2)));
    ep2 = inv_cayley_transform(exp(I*(center_angle + thet/2)));

    circles_start[i + 1][1] = (ep1 + ep2) / 2;
    circles_start[i + 1][2] = abs(ep1 - ep2) / 2;
  );

  /* Now double across first circle in list */
  refl_center = circles_start[1][1];
  refl_rad = circles_start[1][2];
  circles_doubled = vector(4, x, vector(2));

  for(i = 1, 2,
    /* Save old circle */
    circles_doubled[2*i - 1][1] = circles_start[i + 1][1];
    circles_doubled[2*i - 1][2] = circles_start[i + 1][2];

    /* Compute and save reflected circle */
    ep1 = circles_start[i + 1][1] - circles_start[i + 1][2];
    ep2 = circles_start[i + 1][1] + circles_start[i + 1][2];
    ep3 = refl_rad^2 / (ep1 - refl_center) + refl_center;
    ep4 = refl_rad^2 / (ep2 - refl_center) + refl_center;

    circles_doubled[2*i][1] = (ep3 + ep4) / 2;
    circles_doubled[2*i][2] = abs(ep3 - ep4) / 2;
  );

  /* Finally, save shifted circles */
  circles_shifted = vector(5, x, vector(2));
  circles_shifted[1][1] = circles_start[1][1];
  circles_shifted[1][2] = circles_start[1][2];
  ep1 = circles_start[1][1] - circles_start[1][2];
  ep2 = circles_start[1][1] + circles_start[1][2];

  /* Mapping of 0 -> infty by R2R1 */
  ep3 = circles_start[2][1];
  ep4 = reflect(0, circles_start[2][1], circles_start[2][2]);
  circles_shifted[2][1] = (ep3 + ep4)/2;
  circles_shifted[2][2] = abs(ep3 - ep4)/2;

  /* Mapping of R1 by R2R1 */
  ep3 = reflect(ep1, circles_start[2][1], circles_start[2][2]);
  ep4 = reflect(ep2, circles_start[2][1], circles_start[2][2]);
  circles_shifted[3][1] = (ep3 + ep4)/2;
  circles_shifted[3][2] = abs(ep3 - ep4)/2;

  /* Mapping of 0 -> infty by R3R1 */
  ep3 = circles_start[3][1];
  ep4 = reflect(0, circles_start[3][1], circles_start[3][2]);
  circles_shifted[4][1] = (ep3 + ep4)/2;
  circles_shifted[4][2] = abs(ep3 - ep4)/2;

  /* Mapping of R1 by R3R1 */
  ep3 = reflect(ep1, circles_start[3][1], circles_start[3][2]);
  ep4 = reflect(ep2, circles_start[3][1], circles_start[3][2]);
  circles_shifted[5][1] = (ep3 + ep4)/2;
  circles_shifted[5][2] = abs(ep3 - ep4)/2;

  return([circles_doubled, refl_center, refl_rad, circles_shifted]);
}

/*
Given two (center, radius) pairs (c, r) and (a, t), computes the fixed
points of the Mobius transformation obtained from reflection across the
first circle composed with reflection across the second circle
*/
fixed_points_refls(c, r, a, t)=
{
  local(A, B);
  A = (c^2 - a^2 + t^2 - r^2)/2/(c - a);
  B = sqrt(( (a - c)^2 - (r^2 + t^2) )^2 - 4*r^2*t^2 )/2/(c - a);
  return([A - B, A + B]);
}

/*
Given circles data (as obtained by get_circle_data), compute the
data needed to map to each of the flare domains, [z1, z2, t, pre_kappa]:
  - z1, z2: endpoints of the geodesic cutting off the flare
  - t: leftmost point of the flare
  - pre_kappa: rightmost point of the flare

  RECALL: circles_doubled order is R2, R1R2, R3, R1R3
          refl_center, refl_rad gives R1 info
          circles_shifted order is R1, R2(im_axis), R2(R1),
                                   R3(im_axis), R3(R1)
*/
get_flare_data(circles_doubled, refl_center, refl_rad, circles_shifted)=
{
  local(flare_data, temp, temp_new);

  flare_data = vector(3, x, vector(4));

  /* first flare is between R1 and R2(R1) */
  temp = fixed_points_refls(refl_center, refl_rad,
                            circles_doubled[1][1], circles_doubled[1][2]);
  flare_data[1][1] = min(real(temp[1]), real(temp[2]));
  flare_data[1][2] = max(real(temp[1]), real(temp[2]));
  flare_data[1][3] = refl_center - refl_rad;
  flare_data[1][4] = circles_shifted[3][1] - circles_shifted[3][2];

  /* second flare is between R3(R1) and R1 */
  temp = fixed_points_refls(refl_center, refl_rad,
                            circles_doubled[3][1], circles_doubled[3][2]);
  flare_data[2][1] = min(real(temp[1]), real(temp[2]));
  flare_data[2][2] = max(real(temp[1]), real(temp[2]));
  flare_data[2][3] = circles_shifted[5][1] + circles_shifted[5][2];
  flare_data[2][4] = refl_center + refl_rad;

  /* third flare is between R2(im_axis) and R3(im_axis) */
  temp = fixed_points_refls(circles_doubled[1][1], circles_doubled[1][2],
                            circles_doubled[3][1], circles_doubled[3][2]);
  flare_data[3][1] = min(real(temp[1]), real(temp[2]));
  flare_data[3][2] = max(real(temp[1]), real(temp[2]));
  flare_data[3][3] = circles_shifted[2][1] + circles_shifted[2][2];
  flare_data[3][4] = circles_shifted[4][1] - circles_shifted[4][2];

  return(flare_data);
}

/*
Pullback to fundamental domain; that is, outside all circles.
*/
pullback_Schottky(z_start, circles_doubled, refl_cent, refl_rad)=
{
  local(z, in_FD, cent, rad);

  z = z_start;
  while(1,

    /*
    check each circle; recall circle order is [R2, R1R2, R3, R1R3]
    */
    in_FD = 1;

    /* check if in R2 */
    if(abs(z - circles_doubled[1][1]) < circles_doubled[1][2],
      /* map by R1R2 */
      z = reflect(z, circles_doubled[1][1], circles_doubled[1][2]);
      z = reflect(z, refl_cent, refl_rad);
      in_FD = 0;
    );

    /* check if in R1R2 */
    if(in_FD == 1 & abs(z - circles_doubled[2][1]) < circles_doubled[2][2],
      /* map by R2R1 */
      z = reflect(z, refl_cent, refl_rad);
      z = reflect(z, circles_doubled[1][1], circles_doubled[1][2]);
      in_FD = 0;
    );

    /* check if in R3 */
    if(in_FD == 1 & abs(z - circles_doubled[3][1]) < circles_doubled[3][2],
      /* map by R1R3 */
      z = reflect(z, circles_doubled[3][1], circles_doubled[3][2]);
      z = reflect(z, refl_cent, refl_rad);
      in_FD = 0;
    );

    /* check if in R1R3 */
    if(in_FD == 1 & abs(z - circles_doubled[4][1]) < circles_doubled[4][2],
      /* map by R3R1 */
      z = reflect(z, refl_cent, refl_rad);
      z = reflect(z, circles_doubled[3][1], circles_doubled[3][2]);
      in_FD = 0;
    );

    /* If we passed all those tests, z is in original fundamental domain.
       Want to return z in shifted domain */
    if(in_FD == 1,
      /* If z is in F1 or F2, map it by R2R1 or R3R1, resp. */
      if(abs(z - refl_cent) >= refl_rad,
        if(real(z) < 0,
          z = reflect(z, refl_cent, refl_rad);
          return(reflect(z, circles_doubled[1][1], circles_doubled[1][2]));
          ,
          z = reflect(z, refl_cent, refl_rad);
          return(reflect(z, circles_doubled[3][1], circles_doubled[3][2]));
        );
      );
      return(z);
    );

    /* If we ever end back at z_start, in an infinite loop */
    if(abs(z - z_start) < 1e-10,
      print("Warning: pullback algorithm for "z_start" returned to self.");
      return(z_start)
    );
  );
}

/*
Map from flare domain to original domain
*/
hyp_to_true(rho, th, z1, z2, t) =
{
  local(w, c);

  c = (t - z2)/(t - z1);
  w = rho*exp(th*I);
  (z2*w - c*z1)/(w - c);
}

/*
Map from original domain to flare domain
*/
true_to_hyp(z, z1, z2, t)=
{
  local(w, c);

  c = (t - z2)/(t - z1);
  w = c*(z - z1)/(z - z2);
  [abs(w), arg(w)];
}

/**********************************************************************
  Linear algebra algorithm (from Strombergsson)
**********************************************************************/

/*
 To utilize as much information as possible, we will typically be looking
 at a linear system with more equations than variables. In particular, we
 have a system of the type "A*x=0", where x is the sought for M-dimensional
 vector of Fourier coefficients, and A is an N*M-matrix where N>=M-1
 is the number of given points. Of course, since typically N should be
 much larger than M, it will be impossible to find an EXACT solution x
 to "A*x=0". Instead we seek x so as to MINIMIZE |A*x| (Euclidean norm).
 for some given normalization of x. Perhaps the most natural normalization
 of x would be |x|=1; however here we instead normalize by setting
 x[1]=1. Thus, since |A*x|^2=x^t*AA*x with AA:=A^t*A (an M*M-matrix), it
 turns out that we wish to find that vector x which satisfies x[1]=1 and
 AA'*x=0, where AA' is the (M-1)*M-matrix obtained by removing the top row
 from AA. We find this vector x using Gauss elimination, via solve_sys.
*/

/*
 The following routine solves a linear system of equations using
 Gauss elimination. Of course we could instead have tried to make
 use of some built-in PARI routine, but we wanted to have maximal
 control. Actually the routine below is a very downscaled version
 of a much longer routine, which e.g. allows a higher dimensional
 solution space (e.g. when looking for holomorphic modular forms)
 and also allows some "tricks", e.g. to have available more
 equations than are actually used in the end, so that in each new
 j-iteration we seek among more than one row to find a good pivot.
 (This is probably humbug to any expert in numerical linear algebra,
 but it has been found to work well in practice when dealing with a
 higher dimensional space of holomorphic modular forms.) Anyway,
 I have taken this away below since I doubt it would be useful for
 the problem we are now discussing.)
*/

/*
 Solve the homogeneous system of equations whose coefficients are
 given by AA using Gauss elimination.
 cfree is the index of the column which should be kept as a free variable.
*/
solve_sys(AA, cfree)=
{
  local(Nequ, Nu, c, maxc, maxk, columninfo, j, k, A, N, jj);

  /* get number of equations and variables */
  Nequ = matsize(AA)[2];
  Nu = matsize(AA[1])[2];

  /* We maintain  columninfo  so that
    columninfo[k] = j   if column k has been used as pivot column and
                          the corresponding "1" is in row j.
                  = -1  if column k has not yet been used as pivot. */
  columninfo=vector(Nu,k,-1);

  /* loop through rows */
  for(j=1,Nequ,
    /* Find the coefficient of largest absolute value in row number j. */
    maxc=0; maxk=-1;
    for(k=1,Nu, if((k!=cfree),
      c=abs(AA[j][k]); if((c>maxc), maxk=k; maxc=c;);
    ););
    if((maxk==-1), error("In solveequsyst; unexpected linear dependence "j););

    /* Divide all coefficients in row j  with  AA[j,maxk]. */
    A=1/AA[j][maxk];
    AA[j]=A*AA[j];
    AA[j][maxk]=1;    /* EXACT 1, not "1.000000000023", say! */

    /* Update columninfo. */
    columninfo[maxk]=j;

    /* Subtract row j from all other rows. */
    for(N=1,Nequ,
      if(N != j,
        A=AA[N][maxk];
        AA[N] = AA[N]-A*AA[j];
        AA[N][maxk]=0;   /* EXACT 0, not "0.0E-10", say! */
      );
    );
  );

  /* Return the solution vector. */
  vector(Nu, k, if(k==cfree, 1, -AA[columninfo[k]][cfree]));
}

/**********************************************************************
  Code for setting up and solving linear system
**********************************************************************/

/*
Finds best two admissible flares for z (if they exist).
Smaller argument means better flare.
*/
get_best_flares(z, flare_data, alpha0)=
{
  local(best_flares, ang1, ang2, ang);
  best_flares = [0, 0];
  ang1 = 2*Pi;
  ang2 = 2*Pi;

  /* Check argument at each flare */
  for(i = 1, 3,
    ang = true_to_hyp(z, flare_data[i][1], flare_data[i][2], flare_data[i][3])[2];

    /* If admissible, might be included */
    if(ang <= alpha0,
      /* Check if new best */
      if(ang < ang1,
        /* replace second best with first, then save new best */
        ang2 = ang1;
        best_flares[2] = best_flares[1];
        ang1 = ang;
        best_flares[1] = i;

        ,
        /* otherwise, check if new second best */
        if(ang < ang2,
          /* replace second best with new */
          ang2 = ang;
          best_flares[2] = i;
        );
      );
    );
  );
  return(best_flares);
}

/*
Sets up matrix of equations for list of test points z
  - use flare and disk expansions
    - if test point is in fundamental domain, compare best two admissible
      expansions to each other
    - else, compare best admissible expansion at test point to best admissible
      expansion at pullback
  - lambda = s(1 - s)
  - only use flare expansion if test point has argument <= alpha0
  - M - number of coefficients to take in each flare expansion
*/
init_eqns(zs, s, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad)=
{
  local(num_eqns, j, z, zpb, kappas, best_flares, i, z_flare,
        m, best_flares_pb, B);

  /* kappas are the scaling parameters for the flares */
  kappas = vector(3);
  for(i = 1, 3,
    kappas[i] = true_to_hyp(flare_data[i][4], flare_data[i][1],
                            flare_data[i][2], flare_data[i][3])[1];
  );

  /* every point in the vector z must give 1 equation
     - rows of A correspond to equations
     - cols correspond to coefficients
       - cols 1, ..., M are for first flare expansion
       - cols M+1, ..., 2*M are for second flare expansion
       - cols 2*M+1, ..., 3*M are for third flare expansion */
  A = vector(length(zs), x, vector(3*M));

  /* Loop through all test points */
  for(j = 1, length(zs),
    z = zs[j];
    zpb = pullback_Schottky(z, circles_doubled, R1_cent, R1_rad);

    /* Check whether point is in fundamental domain */
    if(abs(zpb - z) < 1e-10,

      /* Point is IN fundamental domain */

      /* Get equation by comparing best 2 expansions */
      best_flares = get_best_flares(z, flare_data, alpha0);

      /* If no flare worked, error out */
      if(best_flares[1] == 0,
        error("Point "z" not admissible for any flare.");
      );

      /* If only one flare worked, error out */
      if(best_flares[2] == 0,
        error("Point "z" only admissible for one flare.");
      );

      /* Add first expansion */
      i = best_flares[1];
      z_flare = true_to_hyp(z, flare_data[i][1], flare_data[i][2], flare_data[i][3]);
      for(m = 0, M - 1,
        A[j][M*(i - 1) + m + 1] = flare_Whitt(z_flare[2], m, s, kappas[i])
                                   *cos(2*Pi*m*log(z_flare[1])/log(kappas[i]));
      );

      /* Add second expansion */
      i = best_flares[2];
      z_flare = true_to_hyp(z, flare_data[i][1], flare_data[i][2], flare_data[i][3]);
      for(m = 0, M - 1,
        A[j][M*(i - 1) + m + 1] = -flare_Whitt(z_flare[2], m, s, kappas[i])
                                   *cos(2*Pi*m*log(z_flare[1])/log(kappas[i]));
      );

      ,
      /* Point is NOT in fundamental domain */

      /* Get equation by comparing best expansion for z to best for zpb */
      best_flares = get_best_flares(z, flare_data, alpha0);
      best_flares_pb = get_best_flares(zpb, flare_data, alpha0);

      /* If no admissible flare for either point, error out */
      if(best_flares[1] == 0,
        error("Point "z" not admissible for any expansion.");
      );
      if(best_flares_pb[1] == 0,
        error("Pullback "zpb" of point "z" not admissible for any expansion.");
      );

      /* Add first expansion */
      i = best_flares[1];
      z_flare = true_to_hyp(z, flare_data[i][1], flare_data[i][2], flare_data[i][3]);
      for(m = 0, M - 1,
        A[j][M*(i - 1) + m + 1] = flare_Whitt(z_flare[2], m, s, kappas[i])*cos(2*Pi*m*log(z_flare[1])/log(kappas[i]));
      );

      /* Add second expansion */
      i = best_flares_pb[1];
      z_flare = true_to_hyp(zpb, flare_data[i][1], flare_data[i][2], flare_data[i][3]);
      for(m = 0, M - 1,
        A[j][M*(i - 1) + m + 1] -= flare_Whitt(z_flare[2], m, s, kappas[i])*cos(2*Pi*m*log(z_flare[1])/log(kappas[i]));
      );
    );
  );

  /* return a matrix object */
  B = matrix(length(zs), 3*M, k, j, A[k][j]);
  return(B);
}

/*
Given a set of test points zs, set up and solve linear system for the Fourier
coefficients. Assumes we are working with a symmetric Schottky group.
  - s - assumed eigenvalue is lambda = s(1 - s)
  - only use flare expansion if test point has argument <= alpha0
  - M - number of coefficients to take in each flare expansion
  - flare_data - see get_flare_data above
  - circles_doubled, R1_cent, R1_rad - see get_circle_data above
*/
get_coefficients(zs, s, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad)=
{
  local(k, A, AA, B, x);

  /* Set up matrix of equations */
  A = init_eqns(zs, s, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad);

  /* Use Strombergsson's method for least squares */
  AA = mattranspose(A)*A;
  B = vector(3*M-1, k, vector(3*M, j, AA[k+1, j]));
  x = solve_sys(B, 1); /* TODO: maybe play with second argument?
                          (normalize wrt different flare...?) */

  /* return Fourier coefficient vector */
  return(x);
}

/**********************************************************************
  Actual loops for Hejhal's algorithm
**********************************************************************/

/*
Runs a "secant method version" of Hejhal's algorithm (learned from
Strombergsson)
  - s - assumed eigenvalue is lambda = s(1 - s)
  - only use flare expansion if test point has argument <= alpha0
  - M - number of coefficients to take in each flare expansion
  - flare_data - see get_flare_data above
  - circles_doubled, R1_cent, R1_rad - see get_circle_data above
*/
secant_method(z1, z2, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad, s, delta)=
{
  local(s_new, c1, c2, j, s_max, s_min, s_mid, delta_new);

  s_new=vector(4); /* REMEMBER TO CHANGE THIS IF YOU CHANGE C1 AND C2 */

  while(1,

    /* Get differences of some Fourier coefficients for s */
    x1 = get_coefficients(z1, s, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad);
    x2 = get_coefficients(z2, s, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad);
    c1 = [x1[2] - x2[2], x1[3] - x2[3], x1[M+1] - x2[M+1], x1[2*M+1] - x2[2*M+1]];

    /* Now do the same for s + delta */
    x1 = get_coefficients(z1, s + delta, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad);
    x2 = get_coefficients(z2, s + delta, alpha0, M, flare_data, circles_doubled, R1_cent, R1_rad);
    c2 = [x1[2] - x2[2], x1[3] - x2[3], x1[M+1] - x2[M+1], x1[2*M+1] - x2[2*M+1]];

    /* Run one iteration of secant method on each difference */
    s_max = 0.0; s_min = 100.0;
    for(j = 1, length(c1),
      s_new[j] = (c1[j]*(s+delta) - c2[j]*s)/(c1[j] - c2[j]);
      s_max = max(s_max, s_new[j]);
      s_min = min(s_min, s_new[j]);
    );
    s_mid = 0.5*(s_max + s_min);

    /* Uncomment if you want to print current predictions */
    print("--------------------------------------");
    print("Current predictions:");
    for(j = 1, length(c1), print(s_new[j]));
    print(" ");

    /* Ad hoc check if it's worth continuing */
    delta_new = (s_max - s_min)*5;
    if(delta_new > 0.5*delta,
      print("Approximate error:"smax-smin);
      return(s_mid);
    );
    delta = delta_new;
    s = s_mid-0.5*delta;
  );
}

/* TODO: update below here */

/*
Use Hejhal's original zoom in method: search for s in a grid of points,
then look at continually finer grids at best test points.
Get best based on minimum error in Fourier coefficients between two
sets of test points.
*/
grid_zoom_in(z1, z2, r, y0, alpha0, rho0, M1, M2, M3, s_start, grid_size_start, num_steps)=
{
  local(best_s, grid_size, s_list, error_list, R, idx);

  best_s = s_start;
  grid_size = grid_size_start;

  /* repeat process for num_steps */
  for(i = 1, num_steps,
    /* print best s so far */
    print("Current guess: s = "best_s);

    /* get list of guesses */
    s_list = vector(11, n, best_s - 5*grid_size + (n-1)*grid_size);
    error_list = vector(11, n, 0);

    /* loop through grid of s values */
    for(j = 1, 11,
      /* get two sets of coefficients  and store error */
      x1 = get_coefficients_all(z1, r, s_list[j], y0, alpha0, rho0, M1, M2, M3);
      x2 = get_coefficients_all(z2, r, s_list[j], y0, alpha0, rho0, M1, M2, M3);
      error_list[j] = norml2(x1 - x2);
    );

    /* print list of s values and corresponding errors */
    /*print("s guesses: "s_list);
    print("errors: "error_list);*/

    /* get s with minimum error to search near */
    vecmin(error_list, &idx);
    best_s = s_list[idx];

    /* update grid size */
    grid_size = grid_size*0.1;
  );

  return(best_s);
}
