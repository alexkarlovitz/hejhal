from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
import diskModel as dm
import poincareModel as pm

'''
This file contains functions for visualizing the triple cover of a symmetric
Schottky group generated by 3 reflections. The cover is obtained by including
rotation by 2pi/3 as a group element.
'''

# computes inverse Cayley transform
def inv_Cayley(w) :
    if w == 1 :
        return np.inf
    return 1j*(1 + w)/(1 - w)

# maps fundamental domain in disk model to upper half plane
def disk_to_UHP(fd) :
    gs = []

    # apply inverse Cayley transform to each geodesic
    for g in fd.geodesics :
        gs.append(pm.Geodesic(inv_Cayley(g.ep1).real, inv_Cayley(g.ep2).real))

    # if fd has a reference point, map that to upper half plane
    ref_point = None
    if fd.referencePoint != None :
        ref_point = inv_Cayley(fd.referencePoint)

    return pm.FundamentalDomain(gs, ref_point)

# given a hyperbolic matrix A, returns the fixed points of the Mobius
# transformation defined by A
def get_fixed_points(A) :
    tr = A[0, 0] + A[1, 1]

    # matrix must be hyperbolic
    assert abs(tr) > 2, 'matrix must be hyperbolic'

    # if A[1, 0] is 0, infinity and -A[0, 1]/A[0, 0] are fixed points
    if A[1, 0] == 0 :
        return -A[0, 1]/A[0, 0], np.inf

    # otherwise, use quadratic formula to compute fixed points
    z1 = (A[0, 0] - A[1, 1] - np.sqrt(tr**2 - 4))/(2*A[1, 0])
    z2 = (A[0, 0] - A[1, 1] + np.sqrt(tr**2 - 4))/(2*A[1, 0])
    return z1, z2

# returns fundamental domain in the disk for the group generated by
#   - one circle from the symmetric Schottky group with 3 circles of angle
#     thet (we use the rightmost circle, symmetric across the real axis)
#   - two reflections across diameters which compose to obtain rotation by
#     2pi/3 (we use the real line and the rotation of that by pi/3)
def get_reflection_group(thet) :
    # form the geodesics
    R = dm.Geodesic(np.exp(1j*thet/2), np.exp(-1j*thet/2))
    D1 = dm.Geodesic(np.exp(1j*np.pi/3), -np.exp(1j*np.pi/3))
    D2 = dm.Geodesic(-1, 1)

    # return the fundamental domain with an appropriate reference point
    return dm.FundamentalDomain([R, D1, D2], 0.1 + 1j*0.1)

# draws a fundamental domain in the disk for the group as given by
# get_reflection_group()
def draw_reflection_group(thet) :
    # get fundamental domain
    fd = get_reflection_group(thet)

    # plot it!
    ax = dm.setupFig()
    fd.draw(ax)

    # label geodesics
    plt.text(np.cos(thet/2) + 0.02, np.sin(thet/2) + 0.02, '$R$', fontsize=12)
    plt.text(0.52, 0.88, '$D_1$', fontsize=12)
    plt.text(1.02, 0, '$D_2$', fontsize=12)

    plt.axis('off')
    plt.show()

# returns fundamental domain for group obtained by doubling reflection group
# across D1
def get_doubled_group(thet) :
    # form the geodesics for the fundamental domain
    R = dm.Geodesic(np.exp(1j*thet/2), np.exp(-1j*thet/2))
    D1R = dm.Geodesic(np.exp(1j*(2*np.pi/3 - thet/2)), np.exp(1j*(2*np.pi/3 + thet/2)))
    D2 = dm.Geodesic(-1, 1)
    D1D2 = dm.Geodesic(np.exp(1j*2*np.pi/3), -np.exp(1j*2*np.pi/3))

    # return the fundamental domain with an appropriate reference point
    return dm.FundamentalDomain([R, D1R, D2, D1D2], 0.6 + 1j*0.6)

# draws a fundamental domain in the disk for the group as given by
# get_doubled_group()
def draw_doubled_group(thet, show_axis=False) :
    # get fundamental domain
    fd = get_doubled_group(thet)

    # we'll also plot D1 as a dashed line
    D1 = dm.Geodesic(np.exp(1j*np.pi/3), -np.exp(1j*np.pi/3))

    # plot stuff!
    ax = dm.setupFig()
    fd.draw(ax)
    D1.draw(ax, lstyle='--')

    # if asked, show axis of D1R (this cuts off the flare)
    if show_axis :
        M = 0.5*np.array([ [(-np.sqrt(3) + 1j)/np.sin(thet/2), (np.sqrt(3) - 1j)/np.tan(thet/2)],
                           [(np.sqrt(3) + 1j)/np.tan(thet/2), -(np.sqrt(3) + 1j)/np.sin(thet/2)] ])
        z1, z2 = get_fixed_points(M)
        D = dm.Geodesic(z1, z2)
        D.draw(ax, lstyle=':')
        plt.text(0.98, 0.28, 'Axis of $D_1R$', fontsize=12)

    # label geodesics
    plt.text(np.cos(thet/2) + 0.02, np.sin(thet/2) + 0.02, '$R$', fontsize=12)
    plt.text(0.52, 0.88, '$D_1$', fontsize=12)
    plt.text(1.02, 0, '$D_2$', fontsize=12)
    plt.text(np.cos(2*np.pi/3 - thet/2), np.sin(2*np.pi/3 - thet/2) + 0.02, '$D_1(R)$', fontsize=12)
    plt.text(-0.56, 0.94, '$D_1(D_2)$', fontsize=12)

    plt.axis('off')
    plt.show()

# draws a fundamental domain in the disk for the group as given by
# get_doubled_group() after mapping to upper half plane
def doubled_group_UHP(thet, show_axis=False) :
    # get fundamental domain
    fd = disk_to_UHP(get_doubled_group(thet))

    # we'll also plot image of D1 as a dashed line
    D1 = pm.Geodesic(inv_Cayley(np.exp(1j*np.pi/3)).real,
                     inv_Cayley(-np.exp(1j*np.pi/3)).real)

    # plot stuff!
    ax = pm.setupFig(-4, 4, 0, 4)
    fd.draw(ax, fill=1)
    D1.draw(ax, lstyle='--')

    # label geodesics
    label_pts = []
    labels = []
    label_pts.append(inv_Cayley(np.cos(thet/2) + 1j*np.sin(thet/2)).real)
    labels.append('$R$')
    label_pts.append(inv_Cayley(0.5 + 1j*np.sqrt(3)/2).real)
    labels.append('$D_1$')
    label_pts.append(0)
    labels.append('$D_2$')
    label_pts.append(inv_Cayley(np.cos(2*np.pi/3 - thet/2) + 1j*np.sin(2*np.pi/3 - thet/2)).real)
    labels.append('$D_1(R)$')
    label_pts.append(inv_Cayley(0.5 - 1j*np.sqrt(3)/2).real)
    labels.append('$D_1(D_2)$')

    # if asked, show axis of D1R (this cuts off the flare)
    if show_axis :
        M = 0.5*np.array([ [-np.sqrt(3)*np.tan(thet/4), 1/np.tan(thet/4)],
                           [-np.tan(thet/4), -np.sqrt(3)/np.tan(thet/4)] ])
        z1, z2 = get_fixed_points(M)
        D = pm.Geodesic(z1, z2)
        D.draw(ax, lstyle=':')
        label_pts.append(z2)
        labels.append('Axis of $D_1R$')

    plt.xticks(label_pts, labels)
    plt.yticks([])

    return ax

# draws the flare domain for doubled group
def draw_flare_domain(thet, X, Y) :
    # get fundamental domain
    fd = disk_to_UHP(get_doubled_group(thet))

    # get endpoints of D1R
    M = 0.5*np.array([ [-np.sqrt(3)*np.tan(thet/4), 1/np.tan(thet/4)],
                       [-np.tan(thet/4), -np.sqrt(3)/np.tan(thet/4)] ])
    z2, z1 = get_fixed_points(M) # swapped names to match Tex document
    D = pm.Geodesic(z1, z2)

    # t is the negative endpoint of R
    t = (fd.geodesics[0]).ep1

    # Define Mobius transformation and apply to whole fundamental domain
    mult = (t - z2)/(t - z1)
    U = np.array([ [mult, -z1*mult], [1, -z2] ])
    fd_flare = pm.mobius(U, fd)

    # Draw the fundamental domain!
    ax = pm.setupFig(-X, X, 0, Y)
    fd_flare.draw(ax, fill=1)

    # Let's draw D1 and the axis as well
    D1 = pm.Geodesic(inv_Cayley(np.exp(1j*np.pi/3)).real,
                     inv_Cayley(-np.exp(1j*np.pi/3)).real)
    D1_flare = pm.mobius(U, D1)
    D1_flare.draw(ax, lstyle='--')
    D_flare = pm.mobius(U, D)
    D_flare.draw(ax, lstyle=':')

    # label everything (R, D1R, D2, D1D2)
    labels = ['$U(R)$', '$U(D_1R)$', '$U(D_2)$', '$U(D_1D_2)$', '$U(D_1)$']
    label_pts = []
    for i in range(4) :
        g = fd_flare.geodesics[i]
        if i == 1 or i == 2 :
            label_pts.append(min(g.ep1, g.ep2))
        else :
            label_pts.append(max(g.ep1, g.ep2))
    label_pts.append(max(D1_flare.ep1, D1_flare.ep2))

    plt.xticks(label_pts, labels)
    plt.yticks([])

    plt.show()

# plots points from testPoints.txt along with fundamental domain in the UHP
def plot_test_points() :
    # read file with points
    with open('testPoints.txt') as f :
        line = f.readline().strip()

    # convert point strings to complex numbers
    pts_string = line.replace('I', '1j')
    pts_string = pts_string.replace('*', '').split(',')
    pts = []
    for p in pts_string :
        p_new = ''.join(p.split())
        pts.append(complex(p_new))

    # draw fundamental domain
    ax = doubled_group_UHP(np.pi/2)

    # draw points
    pts = np.array(pts)
    ax.plot(pts.real, pts.imag, '.k')

    plt.show()

if __name__ == '__main__' :
    #draw_doubled_group(np.pi/2, True)
    #doubled_group_UHP(np.pi/2, True)
    #draw_flare_domain(np.pi/2, 5, 5)
    plot_test_points()
